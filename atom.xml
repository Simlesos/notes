<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[莫声谷]]></title>
  <subtitle><![CDATA[突然想到你，笑了笑自己]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://imhzq.com/"/>
  <updated>2016-02-25T14:45:04.000Z</updated>
  <id>http://imhzq.com/</id>
  
  <author>
    <name><![CDATA[sumizu]]></name>
    <email><![CDATA[simlesos@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[修改js词法作用域的几种方式]]></title>
    <link href="http://imhzq.com/2016/01/13/20160113_js_cheat_scope/"/>
    <id>http://imhzq.com/2016/01/13/20160113_js_cheat_scope/</id>
    <published>2016-01-12T16:00:00.000Z</published>
    <updated>2016-02-25T14:45:04.000Z</updated>
    <content type="html"><![CDATA[<p>js中的作用域是词法作用域,也就是完全由编写代码期间函数的位置决定,那能不能人为的修改,创建作用域那?当然是可以的.</p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>虽然 with 已经被弃用,但是了解一下又不会怀孕~ with可以在当前作用域中以传入的对象为基础,创建出一个新的作用域,但是要小心很多坑,看下面这段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj)&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; a: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; b: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fn(o1)); <span class="comment">//=&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(o2)); <span class="comment">//=&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(o1.a);  <span class="comment">//=&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.a);  <span class="comment">//=&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//=&gt; 2</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码中o1有a属性,o2没有a属性,fn函数中接收一个obj参数,在函数中对这个obj对象执行了with,在with块内部,我们对变量a进行简单的此法引用.</p>
<p>这里大家比较有疑问的地方可能是 o2.a 为什么是 undefined,为什么全局对象上多了一个 a 属性?既然说with创建出一个新的作用域,为什么在with块内声明的 c ,还能在外部访问到? 别急,我们一个一个来说.</p>
<p>这段代码中 o1 因为其中有 a 属性,所以LHS找到了 a,并成功赋值成功,而 o2 中并没有 a 属性,因此并不会创建这个属性,所以 o2.a 是 undefined. with创建出的作用域和一般的作用域也是一样的,如果LHS在一层层的作用域中都找不到 a,则会在全局中创建出一个 a,也是就 window 对象上创建出一个 a属性,并赋值为2. </p>
<p>那么 c 为什么能被外部的块访问到那,这是因为 with块虽然可以将一个对象处理为词法作用域,但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中,而是被添加到 with 所处的函数作用域中.</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>eval 可以动态的修改当前作用域,在执行 eval 时,它可以将你写在其中的字符串当做代码,并把这段代码当做就像写在程序中那个位置中一样,就是说,你在 eval 中写的代码,就好像本来就写在那个位置上一样.但同样也有许多坑,来看看下面这个例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'this.a=2'</span>); <span class="comment">//修改当前作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f1.a); <span class="comment">//=&gt; 2;</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码中 eval 对 fn 的词法作用域进行了修改,动态的为 f1 创建除了 a 属性,但有一种特殊情况,如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    e(<span class="string">'this.a=2'</span>); <span class="comment">//修</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f1.a); <span class="comment">//=&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 2;</span></span><br></pre></td></tr></table></figure></p>
<p>这里把 eval 函数赋值给一个变量后, eval 中得 this 指向不再是当前函数中得this,而是全局对象.</p>
<p>eval 还有一个有趣的事情是, eval中得代码不会发生提升,可以试试下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//==&gt; ReferenceError: a is not defined</span></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'var a = 1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<h2 id="try/catch"><a href="#try/catch" class="headerlink" title="try/catch"></a>try/catch</h2><p>try/catch 的 catch块可以创建出一个全新的词法作用域, js中虽然没有块级作用域,但是 catch块可以模拟,参考下面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(o)&#123;</span><br><span class="line">        o = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">//=&gt; ReferenceError: o is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>通过 try/catch 我们可以模拟块级作用域, 可以看到在 catch 块中声明的 b,在外部无法访问,值得注意的是 catch 块中也会有提升行为,并且把行为提升到 fn 作用域中.</p>
<p>熟悉 ES6 的同学,可能知道 let 操作符,可以声明块级作用域, 其实 try/catch 可以完美的模拟出 let. 在一些兼容方案中也是如此.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>with, eval, try/catch 都可以”欺骗”词法环境,但又有各自的缺陷, eval 和 with 因为安全性和性能问题,不推荐大家使用,而 try/catch 在模拟块级作用域,尤其是兼容 let 上还是很有用.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>js中的作用域是词法作用域,也就是完全由编写代码期间函数的位置决定,那能不能人为的修改,创建作用域那?当然是可以的.</p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6之let]]></title>
    <link href="http://imhzq.com/2016/01/12/20160112_js_es6_let/"/>
    <id>http://imhzq.com/2016/01/12/20160112_js_es6_let/</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2016-02-25T15:45:41.000Z</updated>
    <content type="html"><![CDATA[<p>如果以前说 js 中没有块级作用域的话, ES6 后就不能这么说了哦!</p>
<h2 id="u4EC0_u4E48_u662Flet"><a href="#u4EC0_u4E48_u662Flet" class="headerlink" title="什么是let"></a>什么是let</h2><p>let 是 ES6 中新增的关键字, 类似于 var 用来声明变量,但是所声明的变量只有在 let 所在块内有效.换句话说,let 声明的变量隐式地绑定在 let 的包含块中.let 需要在js的 <code>use strict</code> 模式下才能使用.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<h2 id="let_u4E0D_u4F1A_u6709_u63D0_u5347_u884C_u4E3A"><a href="#let_u4E0D_u4F1A_u6709_u63D0_u5347_u884C_u4E3A" class="headerlink" title="let不会有提升行为"></a>let不会有提升行为</h2><p>let 修饰的变量不会有提升行为,如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; ReferenceError</span></span><br><span class="line">        <span class="built_in">console</span>.log(b); <span class="comment">//=&gt; undefined</span></span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>因为没有了提升行为,导致的直接结果就是,let 所在的整个块中, let 声明之前,访问此变量都会发生 ReferenceError.</p>
<h2 id="let_u5FAA_u73AF"><a href="#let_u5FAA_u73AF" class="headerlink" title="let循环"></a>let循环</h2><p>let使用的典型痢疾就是绑定到 for 循环的块中<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var temps = [];</span><br><span class="line">function fn()&#123;</span><br><span class="line"><span class="code">    "use strict"</span></span><br><span class="line"><span class="code">    for(let i = 0; i &lt; 3; i++)&#123;</span></span><br><span class="line"><span class="code">        temps[i] = function()&#123;</span></span><br><span class="line"><span class="code">            console.log(i);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">temps[<span class="link_label">0</span>](<span class="link_url"></span>); //=&gt; 0</span><br><span class="line">temps[<span class="link_label">1</span>](<span class="link_url"></span>); //=&gt; 1</span><br><span class="line">temps[<span class="link_label">2</span>](<span class="link_url"></span>); //=&gt; 2</span><br></pre></td></tr></table></figure></p>
<p>如果不使用 let,按照以前的做法,我们会通过一个闭包,将每次循环的 i 保存下来,现在有了 let 就方便多了.</p>
<p>实际上 let 不仅将 i 绑定到了 for 循环的块中, 事实上它将其重新绑定到了循环中的每个迭代中, 确保使用上一个循环结束时的值重新进行赋值, 就好像 C#,java 中一样.看起来就像这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        let i = j;  <span class="comment">//每个迭代重新绑定</span></span><br><span class="line">        console.<span class="built_in">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="let_u4E0D_u5141_u8BB8_u91CD_u590D_u58F0_u660E"><a href="#let_u4E0D_u5141_u8BB8_u91CD_u590D_u58F0_u660E" class="headerlink" title="let不允许重复声明"></a>let不允许重复声明</h2><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>; <span class="comment">//ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6A21_u62DF_let"><a href="#u6A21_u62DF_let" class="headerlink" title="模拟 let"></a>模拟 let</h2><p>在不支持 ES6 的代理环境中,可以使用 try/catch 来模拟会计作用域,详情可以看 <code>修改js词法作用域那篇文章</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果以前说 js 中没有块级作用域的话, ES6 后就不能这么说了哦!</p>
<h2 id="u4EC0_u4E48_u662Flet"><a href="#u4EC0_u4E48_u662Flet" class="headerlink" title="什么是let"><]]>
    </summary>
    
      <category term="ES6" scheme="http://imhzq.com/tags/ES6/"/>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS中的提升]]></title>
    <link href="http://imhzq.com/2016/01/10/20160110_js_variable_up/"/>
    <id>http://imhzq.com/2016/01/10/20160110_js_variable_up/</id>
    <published>2016-01-09T16:00:00.000Z</published>
    <updated>2016-02-23T17:09:45.000Z</updated>
    <content type="html"><![CDATA[<p>离得越近,其实看见的越少  - 《惊天魔盗团》</p>
<h2 id="u63D0_u5347"><a href="#u63D0_u5347" class="headerlink" title="提升"></a>提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码大家都知道因为变量提升原因,执行起来是这样子的:<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span><span class="comment">&#123;</span><br><span class="line">    var a;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a = 2</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="title">fn</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>这看起来就好像函数和变量的声明被移动到了最上面,这就是<code>提升</code>,每个作用域都会提升,比如例子中的全局作用域和 fn函数作用域都发生了提升</p>
<h2 id="u51FD_u6570_u63D0_u5347"><a href="#u51FD_u6570_u63D0_u5347" class="headerlink" title="函数提升"></a>函数提升</h2><p>上面的例子可以看出,函数声明也会提升,那函数表达式那? 实践是检验真理的唯一标准, 一起来看看下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a(); <span class="comment">//=&gt; TypeError: a is not function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案是函数表达式不会提前.这段代码经过编译后的样子大概是这样的:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a();</span><br><span class="line">a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = argument.callee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u51FD_u6570_u4F18_u5148"><a href="#u51FD_u6570_u4F18_u5148" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明提升,谁优先? 老样子,还是来段代码就知道了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn(); <span class="comment">//=&gt;2</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数声明提升优先于函数表达式和变量声明,上面的代码编译后的样子大概是这个样子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** var fn; **/</span> <span class="comment">//当前作用域中已经声明了fn,所以该提升会被忽略</span></span><br><span class="line">fn();</span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里想必大家都清楚了提升问题,下面就来谈谈重点,为什么会有提升?</p>
<h2 id="u4E3A_u4EC0_u4E48_u4F1A_u6709_u63D0_u5347_u8FD9_u79CD_u73B0_u8C61_3F"><a href="#u4E3A_u4EC0_u4E48_u4F1A_u6709_u63D0_u5347_u8FD9_u79CD_u73B0_u8C61_3F" class="headerlink" title="为什么会有提升这种现象?"></a>为什么会有提升这种现象?</h2><p>说到提升现象,就不得不提作用域,js的作用域不同于JAVA,C#的动态作用域,而是词法作用域,在js执行前,会有一个编译阶段,其中有一步会先将我们的代码进行语法分析生成抽象语法树,然后基于语法树会生成相应的作用域对象,再找到所有的声明并分别与合适的作用域对象关联起来.这样的结果也就是js的作用域与执行的位置无关,只与定义的环境有关,也就是只与我们所写的位置有关,这也就是词法作用域了.</p>
<p>所以,我认为变量提升,就是js实现词法作用域的副产品.又或者说是词法作用域实现的一种方式.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>离得越近,其实看见的越少  - 《惊天魔盗团》</p>
<h2 id="u63D0_u5347"><a href="#u63D0_u5347" class="headerlink" title="提升"></a>提升</h2><figure class="highlight]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flex简明教程(二)]]></title>
    <link href="http://imhzq.com/2016/01/06/20160106_css_flex2/"/>
    <id>http://imhzq.com/2016/01/06/20160106_css_flex2/</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-02-22T16:44:10.000Z</updated>
    <content type="html"><![CDATA[<p>接上次flex的文章,这次我们讲 flex 剩下的两种属性-弹性属性和对其属性</p>
<h2 id="u5F39_u6027_u5C5E_u6027"><a href="#u5F39_u6027_u5C5E_u6027" class="headerlink" title="弹性属性"></a>弹性属性</h2><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>: 数字值,默认值为auto,设置 flex item 主轴(row/column)的最小宽/高,通常配合grow 和 shrink使用</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>: 数字值,默认值是0,设置扩展因子作为比率分配<code>剩余空间</code>,不能为负值<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/r3oq0xf5/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>flex-shrink</code>:数字值,默认值为1,设置的收缩因子作为比率来收缩<code>超出空间</code><br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/57pa5r1y/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>: 这个属性是 flex-grow, flex-shrink, flex-basis 的缩写形式,默认值为 1, 1, 0;</p>
<h2 id="u5BF9_u9F50_u5C5E_u6027"><a href="#u5BF9_u9F50_u5C5E_u6027" class="headerlink" title="对齐属性"></a>对齐属性</h2><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>: 定义主轴上的对齐方式。当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制。<br>justify-content: flex-start(默认值) | flex-end | center | space-between | space-around;<br>flex-start: 左/上对齐<br>flex-end: 右/下对齐<br>center: 居中对齐<br>space-between: flex item 的两端对其<br>space-around: 每个 flex item 的两端间隔相等, 此时flex item之间的间距将是两边flex item距离边框距离的两倍<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/wv3uLgem/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>: 定义辅轴方向上的对其方式.<br>align-items: flex-start | flex-end | center | baseline | stretch(默认值)<br>flex-start：弹性盒子元素的辅轴起始位置的边界紧靠住该行的侧轴起始边界。<br>flex-end：弹性盒子元素的辅轴起始位置的边界紧靠住该行的侧轴结束边界。<br>center：弹性盒子元素在该行的辅轴上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。<br>baseline：如弹性盒子元素的行内轴与辅轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。<br>stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/kn9yxLs2/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>: 定义flex item单独在辅轴方向上的对齐方式。<br>align-self：auto(默认) | flex-start | flex-end | center | baseline | stretch<br>参数和 <code>align-item</code> 一致,只是用来控制单个 flex item对象,可以参考<code>align-item</code></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>: 当伸缩容器的辅轴出现多行还有多余空间时，这个属性可以用来调准「伸缩行」在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的 <code>justify-content</code> 属性类似。请注意本属性在只有一行的伸缩容器上没有效果。<br>align-content：flex-start | flex-end | center | space-between | space-around | stretch(默认)<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/pgq68svy/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<p>到这里,flex属性已经讲完了,下一篇我们再来讲讲flex的应用!睡觉~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上次flex的文章,这次我们讲 flex 剩下的两种属性-弹性属性和对其属性</p>
<h2 id="u5F39_u6027_u5C5E_u6027"><a href="#u5F39_u6027_u5C5E_u6027" class="headerlink" title=]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flex简明教程(一)]]></title>
    <link href="http://imhzq.com/2016/01/05/20160105_css_flex1/"/>
    <id>http://imhzq.com/2016/01/05/20160105_css_flex1/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-02-22T16:44:10.000Z</updated>
    <content type="html"><![CDATA[<p>传统的 css 布局采用盒模型,通过一些列定位属性来布局,但是对于垂直居中,等分这类特殊情况处理起来就比较麻烦,虽然使用负外边距,table-cell等方式也能兼容实现,但是始终是一种 hack.</p>
<h2 id="u4EC0_u4E48_u662Fflex"><a href="#u4EC0_u4E48_u662Fflex" class="headerlink" title="什么是flex"></a>什么是flex</h2><p>flex 又称弹性盒布局,顾名思义,就是可以根据设定的拉伸和收缩因子拉伸或者收缩空间,写过 android 布局的同学是不是会想起来 <code>android:layout_weight</code>啊~,没错就是一个意思!</p>
<p>查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Browser_compatibility" target="_blank" rel="external">flex浏览器兼容性</a>,IE10+才支持不免有些丧气,不过移动端还是棒棒的~</p>
<h2 id="flex_u57FA_u672C_u8BED_u6CD5"><a href="#flex_u57FA_u672C_u8BED_u6CD5" class="headerlink" title="flex基本语法"></a>flex基本语法</h2><p>任何一个容器都能成为 flex 弹性盒:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;<span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;&#125;</span> </span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="tag">span</span><span class="rules">&#123;<span class="rule"><span class="attribute">display</span>:<span class="value"> inline-flex</span></span>;&#125;</span> <span class="comment">/* 行内元素也可以哦 */</span></span><br></pre></td></tr></table></figure></p>
<p>这样就把一个标准盒模型转变为弹性盒模型,其中仍在文档流中的直接子元素则变为 <code>flex item</code>,看下面这个例子:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- flex item：在文档流且为直接子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">'display:flex;'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span>block<span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">'float:left;'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span>&gt;</span>inline<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">'position:absolute;'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span> <span class="comment">&lt;!-- 不是，绝对定位脱离文档流 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span>inner<span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 不是，不是直接子元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以把 flex 的属性分为三类, 方向属性,弹性属性和对齐属性, 这次我们先来讲方向属性</p>
<h3 id="u65B9_u5411_u5C5E_u6027"><a href="#u65B9_u5411_u5C5E_u6027" class="headerlink" title="方向属性"></a>方向属性</h3><p><code>flex-direction</code>: 决定<code>主轴</code>的方向<br>flex-direction: row(默认值) | row-reverse | column | column-reverse<br>row: 横向从左到右排列（左对齐）。<br>row-reverse: 对齐方式与row相反。<br>column: 纵向从上往下排列（顶对齐）。<br>column-reverse: 对齐方式与column相反。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/7zs2y50j/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<p><code>flex-wrap</code>:<br>flex-wrap: nowrap(默认值) | warp | wrap-reverse<br>nowrap：flex容器为单行,该情况下flex item可能会溢出容器<br>wrap：flex容器为多行,该情况下flex item溢出的部分会被放置到新行，子项内部会发生断行<br>wrap-reverse：反转 wrap 排列。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/rd276drv/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<p><code>flex-flow</code>:<br>flex-flow: &lt;’flex-direction’ || flex-warp&gt;<br>上面两个属性的缩写形式</p>
<p><code>order</code>:<br>order: 整数类型, 默认值为 0<br>用整数值来定义排列顺序，数值小的排在前面,可以为负值。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/1vtujpmu/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>传统的 css 布局采用盒模型,通过一些列定位属性来布局,但是对于垂直居中,等分这类特殊情况处理起来就比较麻烦,虽然使用负外边距,table-cell等方式也能兼容实现,但是始终是一种 hack.</p>
<h2 id="u4EC0_u4E48_u662Fflex"><a ]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js基于时间的动画]]></title>
    <link href="http://imhzq.com/2016/01/01/20160101_js_animation/"/>
    <id>http://imhzq.com/2016/01/01/20160101_js_animation/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2016-02-21T15:11:25.000Z</updated>
    <content type="html"><![CDATA[<p>说起前端动画,不得不提CSS动画和JS动画,这里简单谈谈这两者.</p>
<p>CSS动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.<br>相比之JS动画则依托完备的编程语言,可以对动效的设计进行无限的控制,虽然编写起来相比CSS动画来说较为复杂,但可以通过一些第三方库来快速实现,比如 <a href="http://julian.com/research/velocity/" target="_blank" rel="external">VelocityJS</a> . 当然,事物的好坏永远需要按场景区分, CSS动画和JS动画也是如此,比如说一个简单的按钮 hover 效果,无论怎么看CSS动画都是第一选择,但是如果需要控制一个动画工作流,那JS动画一定更适合了. </p>
<p>有点跑题了…, 回到正文</p>
<h2 id="u5173_u952E_u5E27_u52A8_u753B"><a href="#u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><p>假如现在我们有这样一个需求 <code>让一个 div 向右边移动 300px 的距离</code>, 我们来看看下面这种实现<br><iframe width="100%" height="300" src="http://jsfiddle.net/dq7Ldctf/embedded/js,result/light" frameborder="0" allowfullscreen></iframe></p>
<p>看起来我们实现了这个需求,不过不要急,我们稍稍修改上面代码中的 step 函数,在其中加入这段代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">    <span class="keyword">while</span> ((+<span class="keyword">new</span> <span class="built_in">Date</span> - start) &lt; <span class="number">1000</span>)&#123;&#125; <span class="comment">//阻塞1s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家可以去 jsfiddle 中加入这段代码, 观察后,不难发现这个 div 在 left 值为 200px 的地方停顿了 1000+ms. 大家都知道js是基于事件模型的,我们在 step 函数中 setInterval 其实相当于告诉引擎,帮我在 16.7 毫秒后将这个回调函数加入事件队列,如果引擎空闲就执行,此时我们 while 循环1秒,就会阻塞整个事件队列的运行,也就阻塞了UI线程的渲染,表现出来结果就是我们的div运动停止了1秒多.</p>
<p>这里虽然是人为的加入了阻塞代码,但是在正常的开发过程中,setInterval 和 setTimeout 根本没法保证按我们要求的在固定的间隔执行事件,此时如果我们的动画还是按照 <code>变化量/帧</code> 的方式来执行,就会出现不同设备中动画执行时间不同的情况,在移动端是重灾区.</p>
<h2 id="u57FA_u4E8E_u65F6_u95F4_u7684_u52A8_u753B"><a href="#u57FA_u4E8E_u65F6_u95F4_u7684_u52A8_u753B" class="headerlink" title="基于时间的动画"></a>基于时间的动画</h2><p>在讨论上面所述的问题该如何解决之前,不妨先来看看这个数学题:</p>
<blockquote>
<p>A地和B地相距300m,一辆速度为 5m/s 匀速运动的自行车从A地出发去往B地,请问一分钟后自行车距离A地多远?</p>
</blockquote>
<p>我们用时间 时间 <em> 速度 即可得出 5 </em> 60 = 300,也就是300m, 从这个简单的问题中,我们可以发现我们不必去寄人篱下一帧帧的做动效,不必去管帧率的问题,我们可以从动画开始时间到当前时间计算出动画经过的时间,通过 时间 * 速度,计算出当前动画的偏移量,这样就可以保证我们所有性能的平台下动画都是一个速度进行着.下面我们来修改下上面的代码:<br><iframe width="100%" height="300" src="http://jsfiddle.net/rbdk6z79/embedded/js,result/light" frameborder="0" allowfullscreen></iframe></p>
<p>这里我们改为根据时间来计算偏移量,我的测试环境中弹出的结果应该在 <code>4801</code>,下面我们来看看加入同样阻塞代码后的用时,是不是也增加了1000毫秒那:<br><iframe width="100%" height="300" src="http://jsfiddle.net/2yr24asu/embedded/js,result/light" frameborder="0" allowfullscreen></iframe><br>我的测试环境弹出的石 <code>4865</code>,可以看出虽然加入了阻塞代码,但是因为我们是按照时间来计算偏移量的,所以动画总时间不会偏差过大,各个平台下动画也不会出现有的快有的慢得情况.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>基于时间的动效能够消除不同设备不同环境下动画帧数不同导致的动效速度不同的问题,推荐所有的动效都应该采用基于时间的方式!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起前端动画,不得不提CSS动画和JS动画,这里简单谈谈这两者.</p>
<p>CSS动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.<br>相比之JS]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS3动画-深夜恶搞]]></title>
    <link href="http://imhzq.com/2015/12/15/20151215_css_animation/"/>
    <id>http://imhzq.com/2015/12/15/20151215_css_animation/</id>
    <published>2015-12-14T16:00:00.000Z</published>
    <updated>2016-02-21T15:04:41.000Z</updated>
    <content type="html"><![CDATA[<p>本来只是想复习下 CSS3 动画属性, 但是一上手,就控制不住恶搞的欲望,真是可恶啊!!</p>
<p>预览地址: <a href="http://sandbox.runjs.cn/show/ih3bfqcc" target="_blank" rel="external">RPG Book</a></p>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/rpg2.png" alt="RPG Book预览图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来只是想复习下 CSS3 动画属性, 但是一上手,就控制不住恶搞的欲望,真是可恶啊!!</p>
<p>预览地址: <a href="http://sandbox.runjs.cn/show/ih3bfqcc" target="_blank" rel="external">]]>
    </summary>
    
      <category term="CSS3动画" scheme="http://imhzq.com/tags/CSS3%E5%8A%A8%E7%94%BB/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[String的正则方法和RegExp的正则方法]]></title>
    <link href="http://imhzq.com/2015/12/14/20151214_js-regex/"/>
    <id>http://imhzq.com/2015/12/14/20151214_js-regex/</id>
    <published>2015-12-13T16:00:00.000Z</published>
    <updated>2016-02-21T10:41:01.000Z</updated>
    <content type="html"><![CDATA[<p>JS 关于正则这块的函数在String和RegExp对象上都有一些方法,很容易弄混,网上的文章又介绍的特别乱,于是在这里做下总结.</p>
<h1 id="String__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5"><a href="#String__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5" class="headerlink" title="String 对象上有关正则的方法"></a>String 对象上有关正则的方法</h1><h2 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search"></a>String.prototype.search</h2><p>search 方法接受一个正则表达式作为参数,如果传入一个非正则表达式对象,则会使用 new RegExp(obj) 隐式的将其转化为正则表达式对象.</p>
<p>search 方法会返回正则表达式在字符串中首次匹配的索引,如果没有找到,则返回 -1. 如下面的例子:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phone = <span class="string">"18614086288"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = phone.search(/^<span class="number">1</span>\d[<span class="number">10</span>]$/);</span><br><span class="line">console.log(<span class="literal">result</span>);	//<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法类似于 String.prototype.indexOf,一般用来查找某个字符串是否存在某个模式.</p>
<h2 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace"></a>String.prototype.replace</h2><p>replace 这个方法主要用来替换字符串中的一些字串,接收两个参数</p>
<ol>
<li>一个将要被替换的字符串和一个替换掉第一个字符串的字符串</li>
<li>一个正则对象,这个正则匹配的对象将会被第二个参数替换</li>
</ol>
<p>这里第一个大家肯定没有问题,我们来详细讲下第二组参数:</p>
<h3 id="u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u5B57_u7B26_u4E32"><a href="#u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u5B57_u7B26_u4E32" class="headerlink" title="第一个参数是正则对象,第二个参数是字符串"></a>第一个参数是正则对象,第二个参数是字符串</h3><p>这种情况下,正则的匹配项将会被被第二个字符串替换,值得注意的地方是,这个字符串中可以包含一些特殊的变量名</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th style="text-align:left">代表的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$</td>
<td style="text-align:left">转义$,也就是插入一个”$”</td>
</tr>
<tr>
<td>$&amp;</td>
<td style="text-align:left">插入匹配的整个字串</td>
</tr>
<tr>
<td>&amp;`</td>
<td style="text-align:left">插入当前匹配子串左边的内容</td>
</tr>
<tr>
<td>&amp;’</td>
<td style="text-align:left">插入当前匹配子串右边的内容</td>
</tr>
<tr>
<td>$n</td>
<td style="text-align:left">n是个十进制数,表示插入匹配到的第 n 组</td>
</tr>
</tbody>
</table>
<p>举个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"你的名字叫ABC还是DEF"</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.replace(<span class="regexp">/([A-Za-z]+)/g</span>, <span class="string">"( $1 )"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">//output: 你的名字叫( ABC )还是( DEF )</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u51FD_u6570"><a href="#u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u51FD_u6570" class="headerlink" title="第一个参数是正则对象,第二个参数是函数"></a>第一个参数是正则对象,第二个参数是函数</h3><p>这种情况,是将正则表达式匹配到的子串替换成第二个函数的返回值,这个函数可以接受多个参数</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th style="text-align:left">代表的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>match</td>
<td style="text-align:left">匹配到的子串</td>
</tr>
<tr>
<td>$1,$2,…,$n</td>
<td style="text-align:left">表示匹配到的任意多分组的值[倒数第二个参数]</td>
</tr>
<tr>
<td>index</td>
<td style="text-align:left">表示匹配到的子串,在原字符串中的位置[倒数第一个参数]</td>
</tr>
<tr>
<td>input</td>
<td style="text-align:left">原字符串</td>
</tr>
</tbody>
</table>
<p>再来个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> result = property.replace(<span class="regexp">/-(.)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, $1, index,input</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">//output: vDataModel</span></span><br></pre></td></tr></table></figure></p>
<h2 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match"></a>String.prototype.match</h2><p>这个方法接受一个正则对象做参数,但是有两种情况:</p>
<ol>
<li><p>如果这个正则对象是全局匹配,则返回一个匹配到子项的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> result = property.match(<span class="regexp">/-(.)/g</span>);   <span class="comment">//这里是全局匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">//output: ["-d", "-m"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果这个正则对象不是全局匹配,那么它会返回一个结果数组,这个数组的第一项是匹配到的子串,数组的第二项到第n-2项都是匹配的分组,n-1项是匹配到的子串所在原字符串的索引位置,第n项就是原字符串,其实就是和上面介绍的replace方法第二个参数是函数时候的参数一样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> result = property.match(<span class="regexp">/-(.)/</span>);    <span class="comment">//这里不是全局匹配了</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	</span><br><span class="line"><span class="comment">//output: ["-d", "d", index: 1, input: "v-data-model"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意,这里 match 不论匹配几次都会返回第一个匹配项,并不像 RegExp.exec()一样,第二次执行就会匹配到第二个匹配项!</p>
<h1 id="RegExp__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5"><a href="#RegExp__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5" class="headerlink" title="RegExp 对象上有关正则的方法"></a>RegExp 对象上有关正则的方法</h1><h2 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test"></a>RegExp.prototype.test</h2><p>这个方法就比较简单了,test接收一个待匹配项字符串作为参数,如果匹配成功就返回 true,否则返回 false, 比较简单就不多做说明</p>
<h2 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec"></a>RegExp.prototype.exec</h2><p>这个方法要和 String.prototype.match 分清, exec 接收一个待匹配的字符串, 会返回一个和 String.prototype.match 不带全局查找时一样的返回值,需要注意的是,当这个正则表达式使用 “g” 标志做全局查找时,可以执行多次方法来查找同一个字符串中的匹配项,没有找到时返回 null ,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> patter = <span class="regexp">/-(.)/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = patter.exec(property);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//output: ["-d", "d", index: 1, input: "v-data-model"]</span></span><br><span class="line"><span class="keyword">var</span> result = patter.exec(property);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//output: ["-m", "m", index: 6, input: "v-data-model"]</span></span><br><span class="line"><span class="keyword">var</span> result = patter.exec(property);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//output: null</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>JS 关于正则这块的函数在String和RegExp对象上都有一些方法,很容易弄混,网上的文章又介绍的特别乱,于是在这里做下总结.</p>
<h1 id="String__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[文本溢出显示]]></title>
    <link href="http://imhzq.com/2015/12/13/20151213_css_warp/"/>
    <id>http://imhzq.com/2015/12/13/20151213_css_warp/</id>
    <published>2015-12-12T16:00:00.000Z</published>
    <updated>2015-12-20T16:04:32.000Z</updated>
    <content type="html"><![CDATA[<p>我们写页面的时候经常会遇到，文字超出容器的宽度的情况，通常情况下会对文本进行裁剪，并加上三个点，CSS3 中新增了一个 text-overflow 属性，可以更改文本溢出时的样式，我们这次就来说说这个东西。</p>
<p>上面那个问题可以用这段代码解决：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">text-overflow</span>:<span class="value"> ellipsis</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">white-space</span>:<span class="value"> nowrap</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在我们来看看这段 CSS，text-overflow 有两个个属性: 一个是 <code>clip</code>，这个属性是 text-overflow 的默认属性，表示如果文本溢出则裁剪不做任何操作，另一个是 <code>ellipsis</code> 表示文本溢出时用…代替。ok，这样看似好像可以解决我们的问题了，native，这个text-overflow 只能针对一行文本，多行就没有效果了，那我的文本超过一行会自动换行啊，怎么办？于是我们引入<code>white-space</code> 这个属性，这个属性值比较多，咱们先来看看效果：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/21ojzak1/embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe>
<p><br></p>
<p>用白话文来说就是：</p>
<p><code>normal</code> : <code>合并</code>空格、换行符、制表符为一个空格，文本会<code>自动</code>换行</p>
<p><code>nowrap</code> : <code>合并</code>空格、换行符、制表符为一个空格，文本<code>不会</code>自动换行</p>
<p><code>pre</code>: <code>保留</code>空格、换行符、制表符，文本<code>不会</code>自动换行</p>
<p><code>pre-wrap</code> : <code>保留</code>空格、换行符、制表符，文本<code>会</code>自动换行</p>
<p><code>pre-line</code> : <code>合并</code>空格、制表符为一个空格，<code>保留</code>换行符，文本<code>会</code>自动换行</p>
<p>根绝我们的需求，我们依然需要合并换行符、空格、制表符，但是不要自动换行，所以我们选择 <code>nowrap</code>，最后使用 <code>overflow:hidden;</code> 来隐藏溢出的部分。</p>
<p>有的朋友又会问，那多行溢出是不是就不能用css解决了？当然可以，css无所不能！来 show code：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/5rkz77ek/embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe>
<p>其中的秘诀就在于，盒子内容区的高一定要等于文本的行高，比如这里，我们需要保留 5 行文本，就设置 <code>height:5em;</code> 也可以换算成具体的像素值，最后在盒子右下绝对定位一个 <code>...</code> 元素，盖住最后的文本就结束了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们写页面的时候经常会遇到，文字超出容器的宽度的情况，通常情况下会对文本进行裁剪，并加上三个点，CSS3 中新增了一个 text-overflow 属性，可以更改文本溢出时的样式，我们这次就来说说这个东西。</p>
<p>上面那个问题可以用这段代码解决：</p>
<figu]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IE6/7中的inline-block]]></title>
    <link href="http://imhzq.com/2015/12/12/20151212_css_ie67_inline-block/"/>
    <id>http://imhzq.com/2015/12/12/20151212_css_ie67_inline-block/</id>
    <published>2015-12-11T16:00:00.000Z</published>
    <updated>2015-12-18T15:58:11.000Z</updated>
    <content type="html"><![CDATA[<p>display:inline-block;在ie6、ie7下只有设置在默认显示方式为inline的元素上才会生效。为什么哪？</p>
<p>历史原因，早起的IE浏览器在渲染引擎中，如果所有的元素都应用布局的话，IE的性能会受到很大影响，当时IE团队采用了 layout ，只将布局应用在需要的元素上，通过这种办法来减少布局的性能开销， layout 也就是现在常说的 hasLayout，IE8之后更换了引擎，所以这个问题只会出现在 IE6/7中（5.5 不在考虑范围）。</p>
<p>IE6/7中并不是没有 inline-block，早在IE5.5 中就已经支持了，只是它的 inline-block 比较个性，在 IE6/7 中 display:inline-block 是可以触发 hasLayout 的，触发了 hasLayout 的元素表现出来的特征就是一个独立的矩形容器，可以设置宽高而且不受外部元素的影响，类似于现代浏览器中的 BFC。</p>
<p>在IE6/7中，如果是 inline 元素，只要触发了 hasLayout 的元素都会表现的像 inline-block，所以下面这两种写法都可以实现效果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">span</span><span class="rules">&#123;<span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;&#125;</span> </span><br><span class="line"><span class="tag">span</span><span class="rules">&#123;<span class="rule"><span class="attribute">zoom</span>:<span class="value"><span class="number">1</span></span></span>;&#125;</span> </span><br><span class="line"><span class="comment">/* inline-block 和 zoom 都会触发 haslayout，拥有独立布局，可以设置宽高，此外元素本身是 inline 元素，结果就是表现的和 inline－block 一样 */</span></span><br></pre></td></tr></table></figure></p>
<p>如果是 block 元素，比如div 这类标签:</p>
<p>方案1：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="comment">/* 触发hasLayout，拥有自身布局，然并卵，你依然不是 inline 元素，该独占一行还是独占一行 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>方案2：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;   <span class="comment">/* 触发hasLayout，拥有自身布局，可以设置宽高 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>; <span class="comment">/* 强制改成 inline 元素 */</span></span><br><span class="line">    <span class="comment">/* 此时表现就和 inline－block 一样了 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>方案3:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">zoom</span>:<span class="value"> <span class="number">1</span></span></span>;   <span class="comment">/* 换做 zoom 来触发 hasLayout 效果也一样，拥有自身布局，可以设置宽高 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>; <span class="comment">/* 强制改成 inline 元素 */</span></span><br><span class="line">    <span class="comment">/* 此时表现就和 inline－block 一样了 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>方案4: 加个 IE6/7 hank做兼容<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block; <span class="comment">/* 兼容 IE6/7 的 inline 元素和 现代浏览器*/</span></span><br><span class="line">    *<span class="attribute">display</span>: inline; <span class="comment">/* IE6/7 的block 元素 */</span></span><br><span class="line">    *<span class="attribute">zoom</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就解决了IE6/7中 block元素 inline-block 依旧换行的问题。虽然现在基本上已经不用再兼容 IE6/7 了，但是挖一挖以前的故事还是挺有趣的 :-)</p>
<p>​</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>display:inline-block;在ie6、ie7下只有设置在默认显示方式为inline的元素上才会生效。为什么哪？</p>
<p>历史原因，早起的IE浏览器在渲染引擎中，如果所有的元素都应用布局的话，IE的性能会受到很大影响，当时IE团队采用了 layout ，只]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS反柯里化]]></title>
    <link href="http://imhzq.com/2015/12/11/20151211_js-uncurrying/"/>
    <id>http://imhzq.com/2015/12/11/20151211_js-uncurrying/</id>
    <published>2015-12-10T16:00:00.000Z</published>
    <updated>2015-12-15T16:12:55.000Z</updated>
    <content type="html"><![CDATA[<p>之前讲过<a href="http://imhzq.com/2015/12/10/20151210_js-currying/">柯里化</a>，那反柯里化又是啥？顾名思义，反柯里化就是和柯里化反着来，柯里化是分布计算函数，目的是为了缩小适用范围，创建出一个更剧针对性的函数，而反柯里化则恰恰相反，是为了扩大适用范围，创建一个适用范围更广的函数，使本来只有特定对象才能使用的方法，扩展到更多对象，嗯，听起来和call和apply的功能好像一样了,不过反柯里化连 this 都给提取出来了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">uncurrying</span> = <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">apply</span><span class="params">(self, arguments)</span></span>; <span class="comment">//借用call</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> push  = <span class="keyword">Array</span>.prototype.push.uncurrying();</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">push(<span class="keyword">list</span>, <span class="number">4</span>);</span><br><span class="line">console.log(<span class="keyword">list</span>);	<span class="comment">//[ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>
<p>这里我们通过 uncurrying 函数，将 Array.prototype.push.call 变成了一个通用的push函数，这样以来 push 函数的功能就和 Array.prototype.push.call 一样了，同样不仅仅能操作Array 对象，其他对象也可以。</p>
<p>更令人惊讶的是， Function.prototype.call 和 Function.prototype.apply 也能被 uncurrying：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">uncurrying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">var</span> apply = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">apply</span>.<span class="title">uncurrying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">call(fn, &#123;name: <span class="string">'赵日天'</span>&#125;,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);        <span class="comment">//赵日天 &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125;</span></span><br><span class="line">apply(fn, &#123;name: <span class="string">'李杀神'</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">//李杀神  &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">apply([].push, <span class="keyword">list</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">console.log(<span class="keyword">list</span>);	<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<p>是不是很炫酷？然而并没有什么卵用，只是使得对函数的调用更像 js 的前身 Scheme 了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前讲过<a href="http://imhzq.com/2015/12/10/20151210_js-currying/">柯里化</a>，那反柯里化又是啥？顾名思义，反柯里化就是和柯里化反着来，柯里化是分布计算函数，目的是为了缩小适用范围，创建出一个更剧针对性的函数，]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS柯里化]]></title>
    <link href="http://imhzq.com/2015/12/10/20151210_js-currying/"/>
    <id>http://imhzq.com/2015/12/10/20151210_js-currying/</id>
    <published>2015-12-09T16:00:00.000Z</published>
    <updated>2015-12-15T16:27:50.000Z</updated>
    <content type="html"><![CDATA[<p>柯里化（英语：Currying），是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。白话文就是：一个currying函数首先接受一些参数，接受了这些参数后，函数不会立即求值，而是继续返回一个新的函数，刚才传入的参数以闭包的方式保存起来，待到真正需要求值的时候，之前传入的所有参数再一起用以求值。talk is cheap，show me the code：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = <span class="built_in">arguments</span>.length; i&lt;len;i++)&#123;</span><br><span class="line">			sum+= <span class="built_in">arguments</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">1</span>));		<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">4</span>));		<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>这个函数是个简单的求和函数,每次加入数字，都会做一次求和，但是我们其实并不关心这些，我们只关心最后一次的求和，ok，那我们把这些参数保存起来，然后检查argument的长度，当是0的时候，再一起求和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [];</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> num1 + num2;</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			[].push.apply(args, <span class="built_in">arguments</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">fn1(<span class="number">1</span>);</span><br><span class="line">fn1(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">fn1(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fn1()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>ok，这次我们最后一次才求和，但是这样看起来还是好难受，fn1函数一次又一次的调用，视觉还是体力上都不太好,我们稍稍修改一下上面的函数，让他返回匿名函数本身，方便链式操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [];</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> num1 + num2;</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			[].push.apply(args, <span class="built_in">arguments</span>);</span><br><span class="line">			<span class="keyword">return</span> _fn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">fn1(<span class="number">1</span>)(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">4</span>)(); <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数其实就已经是一个柯里化的例子了，现在再回头看看定义～是不是很简单？最后，我们再将上面这个函数重构一下，提出一个公共的 currying 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [];  <span class="comment">//保存参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123; </span><br><span class="line">			<span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args); <span class="comment">//调用fn</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			[].push.apply(args, <span class="built_in">arguments</span>); <span class="comment">//将新的参数 push到args 数组中保存</span></span><br><span class="line">			<span class="keyword">return</span> _fn; <span class="comment">//返回函数本身，方便链式操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curryFn = currying(fn);</span><br><span class="line">curryFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了一个 currying 函数的编写。</p>
<h2 id="u603B_u7ED3_u67EF_u91CC_u5316_u7684_u4F5C_u7528"><a href="#u603B_u7ED3_u67EF_u91CC_u5316_u7684_u4F5C_u7528" class="headerlink" title="总结柯里化的作用"></a>总结柯里化的作用</h2><ol>
<li>延迟计算，这个上面的栗子已经很好的证明了</li>
<li>参数复用，多次调用同一个参数，并且传递的参数基本上相同，那么来试试柯里化吧</li>
<li>动态创建函数，部分计算后，返回一个新的函数，这样就避免了重复计算。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>柯里化（英语：Currying），是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。白话文就是：一个currying函数首先接受一些参数，接受了这些参数后，函数不会立即求值，而是继续返回一个新的函数，刚才传入的参数以闭包的]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS实现简单的AOP]]></title>
    <link href="http://imhzq.com/2015/12/09/20151209_js-aop/"/>
    <id>http://imhzq.com/2015/12/09/20151209_js-aop/</id>
    <published>2015-12-08T16:00:00.000Z</published>
    <updated>2015-12-15T11:09:57.000Z</updated>
    <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）指的是面向切面编程，比如说ASP.NET的Http管道等，主要作用就是把一些跟核心业务逻辑无关的功能抽出来，比如说日志记录，验证，计时，过滤器，异常处理等这些边边角角的东西，然后在动态的加入业务逻辑模块中，这样可以保证业务模块的纯净和高内聚，而且可以很方便的重用这些模块。</p>
<p>在 C# 中得用反射或者DynamicProxy来实现,JS这类函数式语言实现起来极其简单,如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;	<span class="comment">//保存函数本体</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//返回一个新的函数体，包含函数本体和新增函数</span></span><br><span class="line">		fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); 	<span class="comment">//修正 this 调用新增函数</span></span><br><span class="line">		<span class="keyword">return</span> self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); 	<span class="comment">//修正this， 调用函数本体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> result = self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">		fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"主业务"</span>);</span><br><span class="line">&#125;.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"主业务之前执行"</span>)</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"主业务之后执行"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn();	<span class="comment">//主业务之前执行    主业务     主业务之后执行</span></span><br></pre></td></tr></table></figure>
<p>这里只是个简单的demo，使用时根据具体的业务逻辑适当修改。怎么样，是不是很简单，是不是尝到了函数式语言的甜头了 :-)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>AOP（Aspect Oriented Programming）指的是面向切面编程，比如说ASP.NET的Http管道等，主要作用就是把一些跟核心业务逻辑无关的功能抽出来，比如说日志记录，验证，计时，过滤器，异常处理等这些边边角角的东西，然后在动态的加入业务逻辑模块中，这样]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闭包的应用]]></title>
    <link href="http://imhzq.com/2015/12/08/20151208_js-closure-apply/"/>
    <id>http://imhzq.com/2015/12/08/20151208_js-closure-apply/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-15T08:00:05.000Z</updated>
    <content type="html"><![CDATA[<p>说到闭包就先要了解两个小知识。第一个就是作用域，javascript 的每个函数都有自己的作用域，函数除了可以访问自身作用域的活动对象外，还可以访问外层作用域的活动对象,但外部作用域不能访问内部函数作用域。如果在函数中搜索一个变量没有找到，那么此次搜索会随着代码执行环境，逐层向外部作用域搜索，一直搜索到全局对象为止。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(b);  	<span class="comment">//2</span></span><br><span class="line">		<span class="built_in">console</span>.log(a);		<span class="comment">//1</span></span><br><span class="line">	&#125;</span><br><span class="line">	fun2();</span><br><span class="line">	<span class="built_in">console</span>.log(c)			<span class="comment">//ReferenceError: c is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>
<p>第二个是变量的生命周期，函数内部的活动对象，会随着函数的退出而销毁，但是考虑下面的代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var <span class="function"><span class="keyword">fun</span> = <span class="title">function</span></span>()&#123;</span><br><span class="line">	var i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> function()&#123;</span><br><span class="line">		i++;</span><br><span class="line">		console.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = <span class="function"><span class="keyword">fun</span>();</span><br><span class="line"><span class="title">f</span></span>(); <span class="regexp">//</span><span class="number">2</span></span><br><span class="line">f(); <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">f(); <span class="regexp">//</span><span class="number">4</span></span><br><span class="line">f(); <span class="regexp">//</span><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这里，fun执行完毕后，其中的变量 i 并没有被销毁，因为返回的匿名函数还以引用着 fun 的活动对象，换句话说，fun 执行完毕后，会销毁其执行环境的作用域链，但它的活动对象仍然保留在内存中，直到匿名函数被销毁后，fun 的活动对象才会被销毁。一图抵万言：</p>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/closure.001.jpeg" alt="函数fun执行环境的作用域链和闭包"></p>
<h1 id="u95ED_u5305_u5E94_u7528"><a href="#u95ED_u5305_u5E94_u7528" class="headerlink" title="闭包应用"></a>闭包应用</h1><p>上面两个知识明白后，我们正式切入正题，讲一讲闭包的应用。</p>
<p>先来一个经典的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>3<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>4<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>5<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">".test"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++)&#123;</span><br><span class="line">		nodes[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试这段代码，你会发现每次输出的都是 <code>5</code>。 因为当点击事件结束的时候， for循环已经跑完了，i 此时的值是 5，所以，在onclick事件函数中顺着作用域链从内到外查找变量 i 时，查到的值总是 5。</p>
<p>这个问题可以通过闭包解决，把每次循环的 i 都封闭起来。那么在事件触发由内向外查询 i 的时候，就会先查找到封闭在闭包中的 i，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">".test"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        nodes[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的道理，咱们还能写出这样判断类型的函数：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">Type</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> typeArry = [<span class="string">"String"</span>,<span class="string">"Array"</span>,<span class="string">"Number"</span>,<span class="string">"Function"</span>,<span class="string">"Undefined"</span>,<span class="string">"Object"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = 0, len = typeArry.length; i &lt; len; i++ )&#123;</span><br><span class="line">	(function(i)&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">type</span> =  typeArry[i];</span><br><span class="line">		<span class="keyword">Type</span>[<span class="string">"is"</span> + <span class="keyword">type</span>] = function(obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> Object.prototype.<span class="keyword">toString</span>.call(obj) === <span class="string">"[object "</span>+ <span class="keyword">type</span> +<span class="string">"]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">Type</span>.isArray([])); <span class="comment">//true</span></span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">Type</span>.isString(<span class="string">""</span>)); <span class="comment">//true</span></span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">Type</span>.isString(1)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u5C01_u88C5_u53D8_u91CF"><a href="#u5C01_u88C5_u53D8_u91CF" class="headerlink" title="封装变量"></a>封装变量</h2><p>闭包可以把一些不需要暴露在全局的变量封装成“私有变量”。比如在蝴蝶书中的一个例子，记忆函数，假如我们要写一个计算阶乘的函数，如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="function"><span class="keyword">fun</span>  = <span class="title">function</span></span>(n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n * arguments.callee(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>(5));</span><br><span class="line"><span class="title">console</span></span>.log(<span class="function"><span class="keyword">fun</span>(4));</span><br><span class="line"><span class="title">console</span></span>.log(<span class="function"><span class="keyword">fun</span>(3));</span></span><br></pre></td></tr></table></figure>
<p>这个函数可以正常工作，但是在 fun(5) 中我们已经计算过了 4 和 3 的值了，但是在执行 fun4 和 fun3时又重复计算了，这严重影响了性能，我们可以让该函数记住计算后的值，这样就可以减少计算量了，如下：<br> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1 = (function()&#123;</span><br><span class="line">	<span class="keyword">var</span> memo = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">var</span> recur = function(n)&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="literal">result</span> = memo[n];</span><br><span class="line">		<span class="keyword">if</span>(typeof <span class="literal">result</span> !== <span class="string">"number"</span>)&#123;</span><br><span class="line">			<span class="literal">result</span> = n * recur(n - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> memo[n] = <span class="literal">result</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(fun1(<span class="number">5</span>));</span><br><span class="line">console.log(fun1(<span class="number">4</span>));</span><br><span class="line">console.log(fun1(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<p>我们将 memo 对象封装在了闭包中，无法在外部访问 memo 对象，避免了这个变量在其他地方被不小心修改而引发错误。最后我们来对这段代码进行重构，提出一个通用的记忆函数：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memoizer  = function(memo, func)&#123;</span><br><span class="line">	<span class="keyword">var</span> recur = function(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &amp;&amp; !memo.hasOwnProperty(n))&#123;</span><br><span class="line">			<span class="keyword">var</span> <span class="literal">result</span> = func(n);</span><br><span class="line">			<span class="keyword">return</span> memo[n] = <span class="literal">result</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> meno[n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> memo = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> fun2 = memoizer(memo, fun);</span><br><span class="line">console.log(fun2(<span class="number">5</span>));</span><br><span class="line">console.log(fun2(<span class="number">4</span>));</span><br><span class="line">console.log(fun2(<span class="number">3</span>));</span><br><span class="line">console.log(memo);	//&#123; '<span class="number">0</span>': <span class="number">0</span>, '<span class="number">1</span>': <span class="number">1</span>, '<span class="number">3</span>': <span class="number">6</span>, '<span class="number">4</span>': <span class="number">24</span>, '<span class="number">5</span>': <span class="number">120</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u6A21_u62DF_u9762_u5411_u5BF9_u8C61"><a href="#u6A21_u62DF_u9762_u5411_u5BF9_u8C61" class="headerlink" title="模拟面向对象"></a>模拟面向对象</h2><p>对象以方法的形式保留了过程，而闭包则是在过程中以环境的形式保存了数据，通常面向对象的能实现的功能，用闭包也能实现，比如下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Extent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value++;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Extent();</span><br><span class="line">obj.say() 	<span class="comment">//1</span></span><br><span class="line">obj.say()	<span class="comment">//2</span></span><br><span class="line">obj.say()	<span class="comment">//3</span></span><br><span class="line">obj.say()	<span class="comment">//4</span></span><br></pre></td></tr></table></figure></p>
<p>上面是面向对象的写法，下面来看看闭包的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			value++;</span><br><span class="line">			<span class="built_in">console</span>.log(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> extent = extent();</span><br><span class="line">extent.say()	<span class="comment">//1</span></span><br><span class="line">extent.say()	<span class="comment">//2</span></span><br><span class="line">extent.say()	<span class="comment">//3</span></span><br><span class="line">extent.say()	<span class="comment">//4</span></span><br></pre></td></tr></table></figure></p>
<p>闭包是函数式编程中的一个重要概念，很多设计模式都可以用闭包来实现，也是js学习中的重中之重，更多应用大家自己去发掘吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说到闭包就先要了解两个小知识。第一个就是作用域，javascript 的每个函数都有自己的作用域，函数除了可以访问自身作用域的活动对象外，还可以访问外层作用域的活动对象,但外部作用域不能访问内部函数作用域。如果在函数中搜索一个变量没有找到，那么此次搜索会随着代码执行环境，逐]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片格式]]></title>
    <link href="http://imhzq.com/2015/12/07/20151207_image-type/"/>
    <id>http://imhzq.com/2015/12/07/20151207_image-type/</id>
    <published>2015-12-06T16:00:00.000Z</published>
    <updated>2015-12-19T14:33:56.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个前端，每天与各种各样的图片打交道，那么它们有什么区别？应用场景分别是什么？欢迎收看本期今日xx :-)</p>
<p>我们常见的图片格式有，gif,png,jpeg,ico这几种，哦对，还有google的 <a href="https://zh.wikipedia.org/wiki/WebP" target="_blank" rel="external">WebP</a>。使用图片也要遵照基本法的，咱们先讲图片法。不同格式图像都有着自己的特点，这些特点决定了我们何时何地如何去使用它们。</p>
<h1 id="u56FE_u5F62"><a href="#u56FE_u5F62" class="headerlink" title="图形"></a>图形</h1><p>网站的 logo、图标、草图等都属于图形，这些图像通常由连续的线条或其他尖锐的颜色过渡组成，颜色数量相对较少</p>
<h1 id="u7167_u7247"><a href="#u7167_u7247" class="headerlink" title="照片"></a>照片</h1><p>照片通常包含比较丰富的颜色，并且包含平滑的颜色过渡和渐变。</p>
<p>就图像格式而言，GIF通常用来显示图形，而jpeg更适合显示照片，png两者都合适。</p>
<h1 id="u50CF_u7D20_u548CRGB"><a href="#u50CF_u7D20_u548CRGB" class="headerlink" title="像素和RGB"></a>像素和RGB</h1><p>图像由像素组成，像素是图像最小的信息单元。有多种颜色模型可以来描述像素，比如 RGB、RGBa等。</p>
<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>RGB颜色模型，采用包含红(R)、绿(G)、蓝(B)的数量多少的方式来描述一个像素。R、G、B被称作通道，每种通道的强度范围在 0~255 之间。我们在CSS和HTML中实用的十六禁止的通道值，范围从 00~FF，将强度不同的成分合在一起就组成了不同的颜色。</p>
<h2 id="RGBa"><a href="#RGBa" class="headerlink" title="RGBa"></a>RGBa</h2><p>RGBa 并非一种截然不同的颜色模型，而是在 RGB 的基础上做了扩展。额外的成分 a 代表 alpha（可变的） 透明，值的范围也是0~255，不同的程序和库会以不同的方式展示比如0～100%。</p>
<h2 id="u771F_u8272_u5F69_u56FE_u50CF_u548C_u8C03_u8272_u677F_u56FE_u50CF_u683C_u5F0F"><a href="#u771F_u8272_u5F69_u56FE_u50CF_u548C_u8C03_u8272_u677F_u56FE_u50CF_u683C_u5F0F" class="headerlink" title="真色彩图像和调色板图像格式"></a>真色彩图像和调色板图像格式</h2><p>使用RGB颜色模型究竟可以展现 256x256x256＝16777216 种颜色。可以支持这么多种颜色的图片格式叫真色彩图像格式，比如jpeg和png的真色彩类型。</p>
<p>为了在存储图像信息时节省一些空间，有种技术可以将图像中各种不同的颜色提取出来建立一个表，这个表叫做调色板（也叫索引）。有了这个颜色表，就可以通过将调色板中的条目和每个像素重新匹配。达到重绘整个图像的目的。</p>
<p>gif和png8会限制调色板做多只能包含 256 种颜色，这不是说只可以从 256 中定义好的颜色中选择，而是你可以从 1600w＋的颜色中选择你需要的颜色，但是一个图片只能包含 256 种颜色。</p>
<h2 id="u9694_u884C_u626B_u63CF"><a href="#u9694_u884C_u626B_u63CF" class="headerlink" title="隔行扫描"></a>隔行扫描</h2><p>当网速比较慢的时候，大图会随着下载进度逐行显示。为了提高用户体验，部分图像格式支持对那些连续采样的图像进行隔行扫描。隔行扫描(又被称作渐进式图片)可以让用户在图片下载完成前，看到一个模糊的版本，从而在用户心理上消除页面加载缓慢的感觉。具体可以参考张鑫旭大大的这篇博文 <a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片及其相关</a></p>
<h1 id="u4E0D_u540C_u683C_u5F0F_u56FE_u50CF_u7684_u7279_u6027"><a href="#u4E0D_u540C_u683C_u5F0F_u56FE_u50CF_u7684_u7279_u6027" class="headerlink" title="不同格式图像的特性"></a>不同格式图像的特性</h1><p>看完上面的资料后，咱们来看看gif、jpeg和 png 这 3种格式的区别。</p>
<h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><hr>
<p>gif是一种调色板图片格式，只能包含256种颜色。</p>
<h3 id="u900F_u660E"><a href="#u900F_u660E" class="headerlink" title="透明"></a>透明</h3><p>gif 允许一个二进制类型的透明，要没每个像素要么是完全透明要么就是完全不透明。透明也会占用一个调色板条目，也就只剩下255种颜色可选了。</p>
<h3 id="u52A8_u753B"><a href="#u52A8_u753B" class="headerlink" title="动画"></a>动画</h3><p>gif 格式支持动画。</p>
<h3 id="u65E0_u635F"><a href="#u65E0_u635F" class="headerlink" title="无损"></a>无损</h3><p>gif也是无损的，也就是说你可以打开任意一个 gif 文件，做一些修改，保存关闭时不会损失任何质量。</p>
<h3 id="u9010_u884C_u626B_u63CF"><a href="#u9010_u884C_u626B_u63CF" class="headerlink" title="逐行扫描"></a>逐行扫描</h3><p>生成GIF会使用一个LZW压缩算法来减小文件大小，当压缩gif时，会从上到下一行一行的对像素进行扫描。这种情况下，当图片在水平方向有很多重复颜色时，可以获得更好的压缩效果。</p>
<h3 id="u9694_u884C_u626B_u63CF-1"><a href="#u9694_u884C_u626B_u63CF-1" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>gif支持可选的隔行扫描，由于gif有256色的限制，所以不适合显示照片。gif更适合显示图形，但是png8才是显示图形最佳格式。所以，只有当使用动画时才应该使用 gif。</p>
<h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><hr>
<p>jpeg是一种有损压缩格式，用户可以设置自定义质量级别，这个级别决定了有多少信息会被丢弃。质量级别从0～100，但是就算设置为100，也同样会有一定程度的质量损耗。</p>
<p>当你要对图片进行多项编辑操作室，最好使用无损的图像格式来保存中间结果，然后在完成所有操作后，另存为jpeg格式，否则，你将会在每次保存都丢失一些质量。</p>
<p>有些操作是无损的：</p>
<ol>
<li>旋转（只有在旋转90度、180度、270度的情况下）</li>
<li>裁剪</li>
<li>翻转 (水平或垂直)</li>
<li>从标准模式切换至渐进模式，反之亦然</li>
<li>编辑图像的元数据（在优化jpeg图像时极为重要）</li>
</ol>
<h3 id="u900F_u660E_u548C_u52A8_u753B"><a href="#u900F_u660E_u548C_u52A8_u753B" class="headerlink" title="透明和动画"></a>透明和动画</h3><p>jpeg不支持透明和动画</p>
<h3 id="u9694_u884C_u626B_u63CF-2"><a href="#u9694_u884C_u626B_u63CF-2" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>渐进式jpeg<a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片及其相关</a></p>
<h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><hr>
<p>为了弥补gif格式的缺点，并规避 LZW 算法的专利问题，PNG应运而生。</p>
<h3 id="PNG8"><a href="#PNG8" class="headerlink" title="PNG8"></a>PNG8</h3><p>调色板PNG的别称</p>
<h3 id="PNG24"><a href="#PNG24" class="headerlink" title="PNG24"></a>PNG24</h3><p>真色彩PNG的别称，但是不包括 alpha 通道</p>
<h3 id="PNG32"><a href="#PNG32" class="headerlink" title="PNG32"></a>PNG32</h3><p>真色彩PNG的别称，包括 alpha 通道</p>
<h3 id="u900F_u660E-1"><a href="#u900F_u660E-1" class="headerlink" title="透明"></a>透明</h3><p>PNG支持完全的 alpha 透明，IE6中会出现问题</p>
<h3 id="u52A8_u753B-1"><a href="#u52A8_u753B-1" class="headerlink" title="动画"></a>动画</h3><p>有相关实验的实际应用，但还没有跨浏览器的解决方案</p>
<h3 id="u65E0_u635F-1"><a href="#u65E0_u635F-1" class="headerlink" title="无损"></a>无损</h3><p>与jpeg不，png是一种无损的图像格式：多次编辑不会降低其质量，这使得用真色彩png来保存jpeg的修改过程的中间产物非常合适。</p>
<h3 id="u9010_u884C_u626B_u63CF-1"><a href="#u9010_u884C_u626B_u63CF-1" class="headerlink" title="逐行扫描"></a>逐行扫描</h3><p>和gif格式一样，相对于那些垂直方向有重复颜色的图像来说，png格式对那些水平方向上有重复颜色的图像压缩比更高。so，sprite水平摆放会获得更小的尺寸。</p>
<h3 id="u9694_u884C_u626B_u63CF-3"><a href="#u9694_u884C_u626B_u63CF-3" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>png支持隔行扫描，并使用了比gif更先进的算法，它允许对真实图像进行更好的“预览”，但是大小会更大些。</p>
<h3 id="u548C_GIF__u5BF9_u6BD4"><a href="#u548C_GIF__u5BF9_u6BD4" class="headerlink" title="和 GIF 对比"></a>和 GIF 对比</h3><p>除了不支持动画外，调色板png 拥有gif所有的功能。此外，它还支持 alpha 透明，并且通常压缩比更高，文件大小更小。所以 ，应该尽可能的使用 png8替代 gif。</p>
<p>有一个例外是颜色数量较少的小图片，gif的压缩率会更高些。但是这种小图一般都被放在 css sprite 中，因为 http 请求的开销已经大大超过节省那点带宽，而且用png保存sprite图像可以获得更高的压缩率。</p>
<h3 id="u548C_jpeg__u5BF9_u6BD4"><a href="#u548C_jpeg__u5BF9_u6BD4" class="headerlink" title="和 jpeg 对比"></a>和 jpeg 对比</h3><p>当图像中颜色超过 256中时，需要使用真色彩图像格式。jpeg的压缩比更高，而且一般来说，jpeg也是照片存储的实际标准。但由于 jpeg 是有损的，而且在清晰的颜色过渡周围会有大色块，因此下面情况使用PNG更合适：</p>
<ol>
<li>当图片颜色<code>略微</code>超过256，可以在不损耗人和可见质量的前提下，将图片转化为png8格式。令人惊奇的是，有时候，就算你剥离了 1000种以上的颜色，都不会注意到图片中的所发生的变化</li>
<li>当大色块变得不能接受的时候，比如包含很色颜色的图像或软件菜单的截图，这时候png更好。</li>
</ol>
<h2 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h2><hr>
<p>WebP最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。2011年11月8日，Google开始让WebP支持无损压缩和透明色的功能。但目前只有 chrome 和 opera 浏览器支持原生 WebP 格式。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><h2 id="GIF-1"><a href="#GIF-1" class="headerlink" title="GIF"></a>GIF</h2><h3 id="u4F18_u70B9_3A"><a href="#u4F18_u70B9_3A" class="headerlink" title="优点:"></a>优点:</h3><p>动画、无损</p>
<h3 id="u7F3A_u70B9_uFF1A"><a href="#u7F3A_u70B9_uFF1A" class="headerlink" title="缺点："></a>缺点：</h3><p>256色、压缩比不如 png8（颜色少的小图虽然压缩比比 png8高，但是 sprite 格式的 png 更优）、不支持透明</p>
<h2 id="JPEG-1"><a href="#JPEG-1" class="headerlink" title="JPEG"></a>JPEG</h2><h3 id="u4F18_u70B9_uFF1A"><a href="#u4F18_u70B9_uFF1A" class="headerlink" title="优点："></a>优点：</h3><p>真色彩、压缩比可调</p>
<h3 id="u7F3A_u70B9_uFF1A-1"><a href="#u7F3A_u70B9_uFF1A-1" class="headerlink" title="缺点："></a>缺点：</h3><p>有损、不支持透明和动画</p>
<h2 id="PNG8-1"><a href="#PNG8-1" class="headerlink" title="PNG8"></a>PNG8</h2><h3 id="u4F18_u70B9_uFF1A-1"><a href="#u4F18_u70B9_uFF1A-1" class="headerlink" title="优点："></a>优点：</h3><p>无损、压缩比高、支持 alpha 通道</p>
<h3 id="u7F3A_u70B9_uFF1A-2"><a href="#u7F3A_u70B9_uFF1A-2" class="headerlink" title="缺点："></a>缺点：</h3><p>256色</p>
<h2 id="PNG24/PNG32"><a href="#PNG24/PNG32" class="headerlink" title="PNG24/PNG32"></a>PNG24/PNG32</h2><h3 id="u4F18_u70B9_uFF1A-2"><a href="#u4F18_u70B9_uFF1A-2" class="headerlink" title="优点："></a>优点：</h3><p>无损、真色彩、PNG32支持 alpha 通道、PNG24不支持 alpha 通道</p>
<h3 id="u7F3A_u70B9_uFF1A-3"><a href="#u7F3A_u70B9_uFF1A-3" class="headerlink" title="缺点："></a>缺点：</h3><p>图片较大</p>
<h2 id="u5B9E_u9645_u5E94_u7528"><a href="#u5B9E_u9645_u5E94_u7528" class="headerlink" title="实际应用"></a>实际应用</h2><p>这些格式没有孰优孰略，完全看需求：<br>jpeg通常用在颜色较多、但不要求特别精细的图片上，如照片、宣传图、背景等。<br>png通常用在颜色复杂并且要求特别精细或者有透明需求的图片上，如复杂的logo、图标等。由于无损还可以当做“原图”来存档使用。<br>png8在png的基础上“减去”颜色复杂。<br>gif由于静态部分可以被png8代替，所以通常只用于简单的动画。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个前端，每天与各种各样的图片打交道，那么它们有什么区别？应用场景分别是什么？欢迎收看本期今日xx :-)</p>
<p>我们常见的图片格式有，gif,png,jpeg,ico这几种，哦对，还有google的 <a href="https://zh.wikipedia.]]>
    </summary>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[call和apply]]></title>
    <link href="http://imhzq.com/2015/12/06/20151206_js-call-apply/"/>
    <id>http://imhzq.com/2015/12/06/20151206_js-call-apply/</id>
    <published>2015-12-05T16:00:00.000Z</published>
    <updated>2015-12-14T17:32:45.000Z</updated>
    <content type="html"><![CDATA[<p>ECMAScript 3给 Function 的原型中定义了两个方法，分别是 Function.prototype.call 和 Function.prototype.apply。它们两个都可以改变函数体内 this的指向，区别仅在第二个参数不同。</p>
<p>apply 接受两个参数，第一个参数表示函数体内的 this 的指向；第二个函数表示一个参数数组，也可以是类数组，表示传递给这个函数的参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name: <span class="string">"obj1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">"obj2"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">": my numbers is "</span> + [a, b, c]);  </span><br><span class="line">&#125;</span><br><span class="line">sayNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);	<span class="comment">//window: my numbers is 1,2,3</span></span><br><span class="line">sayNumbers.call(obj1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);		<span class="comment">//obj1: my numbers is 1,2,3</span></span><br><span class="line">sayNumbers.apply(obj2, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);	<span class="comment">//obj2: my numbers is 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>因为 function 的参数就保存在一个 arguments 类数组中，所以 apply 会常用些。这里我们展示了 apply 和 call 的第一个用法：改变 this 的指向，这里我们使用 sayNumbers.call(obj1, 1, 2, 3)，函数体内的 this 就指向的是 obj1，同理 sayNumbers.apply(obj2, [1, 2, 3]) 中的 this 指向的就是 obj2。</p>
<p>大家应该知道在 ECMAScript 5 中新增了一个 Function.prototype.bind 函数，这个方法的作用和call 和 apply 很相似，就是将函数中的this 绑定到一个对象上。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name: <span class="string">"obj1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;.bind(obj1);</span><br><span class="line">sayName();      <span class="comment">// obj1</span></span><br></pre></td></tr></table></figure>
<p>大家会发现这个好像个 call 和 apply 的功能几乎一样啊！然而，如果一样也就没有 bind 存在的理由了，bind 还有第二个参数，除了第一个实参外，传入 bind 的其他实参也会绑定至相对应的实参，这被称作柯里化。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="title">function</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;.bind(null, <span class="number">1</span>);    <span class="comment">//将 1 绑定到 x</span></span><br><span class="line">console.log(<span class="func"><span class="keyword">func</span><span class="params">(<span class="number">2</span>)</span></span>);   <span class="comment">//2 绑定到 y 输出 1+2 ＝ 3</span></span><br></pre></td></tr></table></figure>
<p>我们也可以通过 apply 和 call 来模拟 bind 函数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>,    <span class="comment">//保存原函数</span></span><br><span class="line">		context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">//获得 bind 的第一个参数，上下文对象</span></span><br><span class="line">		args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">//剩余参数转换为数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="comment">//调用apply将context绑定在this上，并且将原函数的参数和bind的参数合并成一个数组做参数</span></span><br><span class="line">		self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.name );	<span class="comment">//hzq</span></span><br><span class="line">	<span class="built_in">console</span>.log( x + y + z );	<span class="comment">//6</span></span><br><span class="line">&#125;.bind(&#123;name:<span class="string">"hzq"</span>&#125;, <span class="number">1</span>);</span><br><span class="line">func(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面我们模拟的 bind 中，我们通过 apply 和 call 借用了数组的 shift、slice和 concat 方法，因为arguments是一个类数组对象，虽然它也有下标，也有length属性，但是它仍然不是数组对象，无法使用Array原型对象的相对应方法，使用apply和call可以让我们借用这些方法，例如我们可以像下面一样操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 将arguments转换为一个真正的数组</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shif.call(<span class="built_in">arguments</span>) <span class="comment">//arguments的第一个元素出列</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(<span class="built_in">arguments</span>,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//给arguments对象增加三个元素</span></span><br></pre></td></tr></table></figure>
<p>原因就是这些数组的方法中都使用了 this，例如V8引擎中的Array.prototype.push的实现：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32( <span class="keyword">this</span>.length );   <span class="comment">//获得原数组长度</span></span><br><span class="line">    <span class="keyword">var</span> m = %_ArgumentsLength();        <span class="comment">//获得push参数的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">this</span>[ i + n] = %_Arguments( i );    <span class="comment">//  复制元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = m + n;    <span class="comment">//重置数组 length 长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;     <span class="comment">//返回长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到，并不是所有对象都可以借用这个push方法的，这个对象得有 length 属性，并且可读写属性。所以下面这种情况也是可行的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">	length: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.push.apply(obj,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);	<span class="comment">//Object &#123;0: 0, 1: 1, 2: 2, 3: 3, length: 4&#125;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ECMAScript 3给 Function 的原型中定义了两个方法，分别是 Function.prototype.call 和 Function.prototype.apply。它们两个都可以改变函数体内 this的指向，区别仅在第二个参数不同。</p>
<p>apply]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js中的this]]></title>
    <link href="http://imhzq.com/2015/12/05/20151205_js-this/"/>
    <id>http://imhzq.com/2015/12/05/20151205_js-this/</id>
    <published>2015-12-04T16:00:00.000Z</published>
    <updated>2015-12-14T17:32:45.000Z</updated>
    <content type="html"><![CDATA[<p>javascript 的 this 虽然和其他语言一样总是指向一个对象，但是具体指向哪个对象是在运行时基于执行环境动态绑定的，并不是函数被声明时的环境。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>因为 with 和 eval 不常使用，这里不再讨论。实际应用中，this 的指向情况大致可分为：</p>
<ol>
<li>作为对象的方法被调用</li>
<li>作为普通数调用</li>
<li>构造函数中调用</li>
</ol>
<h3 id="u4F5C_u4E3A_u5BF9_u8C61_u7684_u65B9_u6CD5_u8C03_u7528"><a href="#u4F5C_u4E3A_u5BF9_u8C61_u7684_u65B9_u6CD5_u8C03_u7528" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为对象的方法调用时，this 指向该对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.saying = <span class="string">"大家都别吵了，给我赵日天一个面子！"</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        saying: <span class="string">"我赵日天第一个表示不服！！"</span>,</span><br><span class="line">        getSaying: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.saying;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getSaying());   <span class="comment">//我赵日天第一个表示不服！！</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F5C_u4E3A_u666E_u901A_u51FD_u6570_u8C03_u7528"><a href="#u4F5C_u4E3A_u666E_u901A_u51FD_u6570_u8C03_u7528" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h3><p>普通函数中的 this 总是指向全局对象，在浏览器中就是 window 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getSaying2 = obj.getSaying;</span><br><span class="line"><span class="built_in">console</span>.log(getSaying2());   <span class="comment">//大家都别吵了，给我赵日天一个面子！</span></span><br></pre></td></tr></table></figure>
<p>当调用 obj.getSaying 时，getSaying 方法是作为 obj 对象的属性被调用的，this 指向 obj。</p>
<p>当通过另一个变量 getSaying2 来引用 obj.getSaying 并调用时，是普通函数调用，this 指向 window 对象。</p>
<p>这点经常会引发一个错误，比如，我们每次写 document.getElementById 会觉得太长了，可不可以替换成成一个短一些的函数，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">getId(<span class="string">"box"</span>);   <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>
<p>这段代码会报错，因为 document.getElementById 方法内部需要用到 this。这个 this 本来应该指向 document 的，但我们通过引用的方式，再调用就成了普通函数调用了 this 指向了 window 而不是 document。</p>
<p>我们可以通过apply 和 call 改变 this 的指向来修复。</p>
<h3 id="u4F5C_u4E3A_u6784_u9020_u51FD_u6570_u8C03_u7528"><a href="#u4F5C_u4E3A_u6784_u9020_u51FD_u6570_u8C03_u7528" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>javascript 中没有类，但是可以从构造器中创建对象，并且提供了 new 运算符，使得看起来更像是在创建类。基本上除了一些内置函数外，大部分函数都可以当作构造函数使用，构造函数和普通函数一模一样，区别就在于被调用的方式。当用 new 运算符调用函数时，该函数就是构造函数，并会返回一个对象，通常情况下，其中的 this 指向的就是这个构造函数返回的那个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">"赵日天"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 赵日天</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>javascript 的 this 虽然和其他语言一样总是指向一个对象，但是具体指向哪个对象是在运行时基于执行环境动态绑定的，并不是函数被声明时的环境。</p>
<h2 id="this"><a href="#this" class="headerlink" title="]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拥抱自由shadowsocks]]></title>
    <link href="http://imhzq.com/2015/12/04/20151204_use-shadowsocks/"/>
    <id>http://imhzq.com/2015/12/04/20151204_use-shadowsocks/</id>
    <published>2015-12-03T16:00:00.000Z</published>
    <updated>2015-12-22T16:07:12.000Z</updated>
    <content type="html"><![CDATA[<p>从 2013 年开始用 <a href="http://jproxy.io/" target="_blank" rel="external">jproxy</a> 已经3年了，最终她也没能逃过魔掌:( ，感谢 <a href="http://weibo.com/xiaojay#_rnd1449301836815" target="_blank" rel="external">xiaojay</a> 大大期间不断的维护！Google 不能访问就好像断网了一样难受，回想那几个小时简直痛不欲生啊！用百度简直想吐，竞价排名去死吧！思来想去，一不做二不休，自己搭个⬆吧！</p>
<h2 id="u8D2D_u4E70_VPS"><a href="#u8D2D_u4E70_VPS" class="headerlink" title="购买 VPS"></a>购买 VPS</h2><p>选来选去，还是选了<a href="https://bandwagonhost.com/index.php" target="_blank" rel="external">搬瓦工</a>，买了$19.99 一年的套餐，配置如下：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RAM</span>: <span class="string">256MB</span></span><br><span class="line"><span class="attribute">Disk</span>: <span class="string">10GB SSD</span></span><br><span class="line"><span class="attribute">Bandwidth</span>: <span class="string">550GB</span></span><br></pre></td></tr></table></figure></p>
<p>对了，在搬瓦工的主页右键显示网页源码，里面有段注释：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Try this promo code: IAMSMART5C48JJ --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>购买的时候，可以加进去。我试了，最大的优惠额度是 5%，支付的时候可以用支付宝支付～</p>
<h2 id="u8BBE_u7F6E_u4E3B_u673A"><a href="#u8BBE_u7F6E_u4E3B_u673A" class="headerlink" title="设置主机"></a>设置主机</h2><p>进入主机控制面板</p>
<h3 id="u66F4_u6362_u7CFB_u7EDF"><a href="#u66F4_u6362_u7CFB_u7EDF" class="headerlink" title="更换系统"></a>更换系统</h3><p>选择 Install new OS，更换新系统，我选择的是  centos-6-x86_64-minimal 内存占用只有 7m 左右，毕竟内存只有 256m，能少占点就少占点:-)</p>
<h3 id="u83B7_u53D6ROOT_u7528_u6237_u5BC6_u7801"><a href="#u83B7_u53D6ROOT_u7528_u6237_u5BC6_u7801" class="headerlink" title="获取ROOT用户密码"></a>获取ROOT用户密码</h3><p>选择 Root Password modification 就可以过的 root 用户密码了，ssh登陆进去<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -p <span class="number">3000</span></span><br></pre></td></tr></table></figure></p>
<p>修改 root 用户密码，创建新用户等等～</p>
<h3 id="u4F7F_u7528_u642C_u74E6_u5DE5_u7684Shadowsocks_Server"><a href="#u4F7F_u7528_u642C_u74E6_u5DE5_u7684Shadowsocks_Server" class="headerlink" title="使用搬瓦工的Shadowsocks Server"></a>使用搬瓦工的Shadowsocks Server</h3><p>选择 Shadowsocks Server，安装 shadowsocks 服务，下载对应的 <a href="https://github.com/shadowsocks" target="_blank" rel="external">shadowscoks客户端</a>,配置上相关参数即可，相当简单！</p>
<h3 id="u4F7F_u7528_shadowsocks-libev"><a href="#u4F7F_u7528_shadowsocks-libev" class="headerlink" title="使用 shadowsocks-libev"></a>使用 shadowsocks-libev</h3><p>shadowsocks-libev 是一个 shadowsocks 协议的轻量级实现，是 shadowsocks-android, shadowsocks-ios 以及 shadowsocks-openwrt 的上游项目。其具有以下特点：</p>
<ol>
<li>体积小巧，静态编译并打包后只有 100 KB。</li>
<li>高并发，基于 libev 实现的异步 I/O，以及基于线程池的异步 DNS，同时连接数可上万。</li>
<li>低资源占用，几乎不占用 CPU 资源，服务器端内存占用一般在 3MB 左右。</li>
<li>跨平台，适用于所有常见硬件平台，已测试通过的包括 x86，ARM 和 MIPS。也适用于大部分 POSIX 的操作系统或平台，包括 Linux，OS X 和 gwin 等。</li>
<li>协议及配置兼容，完全兼容 shadowsocks 协议，且兼容标准实现中的 JSON 风格配置文件，可与任意实现的 shadowsocks 端或服务端搭配使用。</li>
</ol>
<h4 id="u5B89_u88C5_u5FC5_u8981_u7EC4_u4EF6"><a href="#u5B89_u88C5_u5FC5_u8981_u7EC4_u4EF6" class="headerlink" title="安装必要组件"></a>安装必要组件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos: yum <span class="operator"><span class="keyword">install</span> <span class="keyword">build</span>-essential autoconf libtool openssl-devel gcc -y</span><br><span class="line">        yum <span class="keyword">install</span> git -y</span></span><br></pre></td></tr></table></figure>
<h4 id="u4E0B_u8F7D_u53CA_u7F16_u8BD1_shadowsocks-libev"><a href="#u4E0B_u8F7D_u53CA_u7F16_u8BD1_shadowsocks-libev" class="headerlink" title="下载及编译 shadowsocks-libev"></a>下载及编译 shadowsocks-libev</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/madeye/shadowsocks-libev.git</span><br><span class="line"><span class="keyword">cd</span> shadowsocks-libev</span><br><span class="line">./configure</span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFA_ssconfig-json__u6587_u4EF6"><a href="#u521B_u5EFA_ssconfig-json__u6587_u4EF6" class="headerlink" title="创建 ssconfig.json 文件"></a>创建 ssconfig.json 文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"server"</span>:<span class="string">"servier_ip"</span>,   <span class="preprocessor"># 服务器IP</span></span><br><span class="line">        <span class="string">"server_port"</span>:<span class="number">65000</span>,     <span class="preprocessor"># ss服务器所使用的端口号，建议改到<span class="number">30000</span>-<span class="number">60000</span></span></span><br><span class="line">        <span class="string">"password"</span>:<span class="string">"password"</span>,   <span class="preprocessor"># ss服务器密码，轻易不要分享</span></span><br><span class="line">        <span class="string">"timeout"</span>:<span class="number">60</span>,            <span class="preprocessor"># 超时时间，建议设置为<span class="number">60</span></span></span><br><span class="line">        <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>   <span class="preprocessor"># 加密方式，需要和客户端配合设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u8FD0_u884C"><a href="#u8FD0_u884C" class="headerlink" title="运行"></a>运行</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>ss-server -c ~<span class="regexp">/ssconfig.json -f /</span>tmp<span class="regexp">/ss1.pid</span></span><br></pre></td></tr></table></figure>
<p>这时候，打开客户端，设置相关参数就可以了，之后，可以用非 ROOT 用户运行 ss<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 创建 hzq 用户</span></span><br><span class="line">useradd hzq</span><br><span class="line"><span class="preprocessor"># 为hzq创建密码</span></span><br><span class="line">passwd hzq</span><br><span class="line">&gt; 输入两次密码</span><br><span class="line"><span class="preprocessor"># 切换用户至hzq</span></span><br><span class="line">su - hzq</span><br><span class="line"><span class="preprocessor"># 在主目录创建第一个配置文件，配置格式请参考`使用配置文件运行`一节</span></span><br><span class="line">vim ~/ssconfig.json</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 保存完毕即可立即运行</span></span><br><span class="line">/usr/local/bin/ss-server -c ~/ssconfig.json -f /tmp/ss1.pid</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 设置开启自启动</span></span><br><span class="line"><span class="preprocessor"># 我们先切换至root用户</span></span><br><span class="line">su - root</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 接着在启动脚本里加入启动命令</span></span><br><span class="line"><span class="preprocessor"># 指定ss以用户hzq的权限运行</span></span><br><span class="line"><span class="preprocessor"># 执行下面的命令时一定注意文件路径是否正确</span></span><br><span class="line">echo <span class="string">"su - hzq -c \"/usr/local/bin/ss-server -c /home/hzq/config1.json -f /tmp/ss1.pid\""</span> &gt;&gt; /etc/rc.local</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看进程</span></span><br><span class="line">ps -ef|grep ss-server</span><br></pre></td></tr></table></figure></p>
<p>最后来这里 <a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="external">下载SS客户端</a> ,按照配置填写参数,从 GFWlist 更新 PAC 文件,重启浏览器.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>打开 Google ，熟悉的页面又出来了，终于有网了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从 2013 年开始用 <a href="http://jproxy.io/" target="_blank" rel="external">jproxy</a> 已经3年了，最终她也没能逃过魔掌:( ，感谢 <a href="http://weibo.com/xiaoja]]>
    </summary>
    
      <category term="生活" scheme="http://imhzq.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Freedom" scheme="http://imhzq.com/categories/Freedom/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[事件委托]]></title>
    <link href="http://imhzq.com/2015/11/09/20151109_Event-delegation/"/>
    <id>http://imhzq.com/2015/11/09/20151109_Event-delegation/</id>
    <published>2015-11-08T16:00:00.000Z</published>
    <updated>2015-12-15T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>感谢<code>沐剑平</code>同学提出的问题，文章已修改！</p>
<p>我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的 DOM 元素越多，应用程序就越慢。特别是事件绑定通常发生在 onload 时，此时对每一个富交互应用的网页来说都是一个拥堵的时刻。事件绑定占用了处理事件，而且，浏览器需要跟踪每个事件处理器，这也会占用更多的内存。</p>
<p>一种简单的 DOM 事件处理技术就是事件委托。</p>
<p>根据 DOM 标准，每个事件都要经历三个阶段</p>
<ol>
<li>捕获（IE不支持）</li>
<li>到达目标</li>
<li>冒泡 </li>
</ol>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/646E5068-FD77-4934-8981-04596183F3F1.png" alt="img"></p>
<p>对事件委托来说，冒泡就够了，比如说我们想要给下面这段代码中每个 a 标签增加一个点击事件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"links"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item1<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item2<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item3<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item4<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item5<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以把 onclick 事件绑定在 ul 元素上，然后通过 event.target 获得当前冒泡事件对象，再根据业务逻辑判断是否是目标元素的点击事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"links"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName !== <span class="string">"A"</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(target.nodeName + <span class="string">": "</span> + target.textContent);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>(list.addEventListener)&#123;</span><br><span class="line">    list.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(list.attachEvent)&#123;</span><br><span class="line">    list.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    list[<span class="string">"onclick"</span>] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以很好的运行，但是假如我们想要的不是 a 标签，而是 li 标签，尝试修改其中这段代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">target</span>.nodeName !== <span class="string">"LI"</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></p>
<p>运行发现并没有得到想要的结果。如果把刚刚修改的那行代码去掉，再次执行，每次点击li，还是弹出的 a 标签的信息，这也是<code>沐剑平</code>同学提出的问题。</p>
<p>我们这里解释下，因为 Event.target 指向的是事件处理程序当前正在处理的那个元素，事件在冒泡阶段经历的过程是 a &gt; li &gt; ul ，所以刚开始 Event.target 指向的就是 a，之后由于 li 上并没有注册事件处理程序，结果 click 事件就一路冒泡到了 ul 上了，搞明白这个后，咱们把程序修改下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"links"</span>);</span><br><span class="line">    <span class="keyword">var</span> handler = function (<span class="keyword">e</span>)&#123;</span><br><span class="line">        <span class="keyword">e</span> = <span class="keyword">e</span> || <span class="keyword">window</span>.event;</span><br><span class="line">        <span class="keyword">e</span>.preventDefault();</span><br><span class="line">        <span class="keyword">var</span> target = <span class="keyword">e</span>.target || <span class="keyword">e</span>.srcElement, </span><br><span class="line">            currentTarget = <span class="keyword">e</span>.currentTarget;    <span class="comment">//e.currentTarget 是指向绑定事件处理器的对象，这里就是 ul 元素</span></span><br><span class="line">        <span class="keyword">while</span>(target !== currentTarget)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.nodeName === <span class="string">"LI"</span>)&#123;</span><br><span class="line">                console.<span class="literal">log</span>(target.nodeName + <span class="string">": "</span> + target.textContent);</span><br><span class="line">            &#125;</span><br><span class="line">            target = target.parentNode; <span class="comment">//如果不是目标元素，就让 target 等于父元素，再次检查</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">list</span>.addEventListener)&#123;</span><br><span class="line">        <span class="keyword">list</span>.addEventListener(<span class="string">"click"</span>, handler, false);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">list</span>.attachEvent)&#123;</span><br><span class="line">        <span class="keyword">list</span>.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">list</span>[<span class="string">"onclick"</span>] = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这次终于可以了，最后依照惯例，我们重构下，提取公共函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">            addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.addHandler = <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">                        element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attchEvent)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.addHandler = <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">                        element.attchEvent(<span class="string">"on"</span> + type, handler)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.addHandler(element, type, handler);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">window</span>.removeEventListener)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.removeHandler = <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">                        element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.detachEvent)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.removeHandler = <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">                        element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.removeHandler(element, type, handler);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e || <span class="built_in">window</span>.event;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e.target || e.srcElement;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(e.preventDefault) e.preventDefault();</span><br><span class="line">                <span class="keyword">else</span> event.returnValue = <span class="literal">false</span>;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(e.stopPropagation) e.stopPropagation();</span><br><span class="line">                <span class="keyword">else</span> e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">             * 事件委托</span><br><span class="line">             * @param  &#123;[DOM]&#125;   element  [事件绑定元素]</span><br><span class="line">             * @param  &#123;[String]&#125;   type     [绑定事件类型，不加on]</span><br><span class="line">             * @param  &#123;[String]&#125;   nodeName [需要触发的子元素]</span><br><span class="line">             * @param  &#123;Function&#125; fn       [子元素事件函数]</span><br><span class="line">             * @return &#123;[Function]&#125;            [事件handler,用来注销事件]</span><br><span class="line">             */</span></span><br><span class="line">        <span class="keyword">var</span> delegation = <span class="function"><span class="keyword">function</span>(<span class="params">element, type, nodeName, fn</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> event = EventUtil.getEvent(e),</span><br><span class="line">                        target = EventUtil.getTarget(event),</span><br><span class="line">                        currentTarget = event.currentTarget || element;</span><br><span class="line">        </span><br><span class="line">                    EventUtil.preventDefault(event);</span><br><span class="line">        </span><br><span class="line">                    <span class="keyword">while</span>(target !== currentTarget)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nodeName.toUpperCase() === target.nodeName)&#123;</span><br><span class="line">                            fn(target);</span><br><span class="line">                            EventUtil.stopPropagation(event);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target = target.parentNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                EventUtil.addHandler(element, type, handler);</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>使用起来，直接调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"#links"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = delegation(ul, <span class="string">"click"</span>, <span class="string">"li"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target.nodeName);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//EventUtil.removeHandler(ul, "click", handler)   //注销事件</span></span><br></pre></td></tr></table></figure></p>
<p>是不是看起来舒服多了那:-P</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>感谢<code>沐剑平</code>同学提出的问题，文章已修改！</p>
<p>我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS选择器优化]]></title>
    <link href="http://imhzq.com/2015/11/08/20151108_simplifying-css-selectors/"/>
    <id>http://imhzq.com/2015/11/08/20151108_simplifying-css-selectors/</id>
    <published>2015-11-07T16:00:00.000Z</published>
    <updated>2015-12-12T16:06:20.000Z</updated>
    <content type="html"><![CDATA[<p>样式系统从最右边的选择符开始向左边匹配规则。只要当前选择符的左边还有其他的选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。</p>
<h2 id="u6700_u53F3_u8FB9_u4F18_u5148"><a href="#u6700_u53F3_u8FB9_u4F18_u5148" class="headerlink" title="最右边优先"></a>最右边优先</h2><p>我最初的觉得 CSS 选择符一定也是从左到右匹配规则的，就像下面这个例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#header</span> <span class="tag">li</span><span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<p>先找到 id 为 header 的元素，然后把这个样式应用到子元素 li 上。我们知道只有一个 id 为 header 的元素，并且它只有几个 li 元素，这个选择符应该是相当高效的才对。</p>
<p>事实上 <em>CSS 选择符是从右到左进行匹配的。</em> 那么回头看上面那个看似高效的的选择符实际上开销相当高，浏览器必须遍历页面上每个 li 元素并确定其父元素的 id 是否是 header。</p>
<h2 id="u5982_u4F55_u7F16_u5199_u9AD8_u6548_u7684CSS_u9009_u62E9_u7B26"><a href="#u5982_u4F55_u7F16_u5199_u9AD8_u6548_u7684CSS_u9009_u62E9_u7B26" class="headerlink" title="如何编写高效的CSS选择符"></a>如何编写高效的CSS选择符</h2><h3 id="u907F_u514D_u4F7F_u7528_u901A_u914D_u89C4_u5219"><a href="#u907F_u514D_u4F7F_u7528_u901A_u914D_u89C4_u5219" class="headerlink" title="避免使用通配规则"></a>避免使用通配规则</h3><p>除了传统意义的通配符外，相邻兄弟选择符、子选择符、后代选择符和属性选择符都应该避免使用，推荐使用 ID、类和标签选择器</p>
<h3 id="u4E0D_u8981_u9650_u5B9A_ID__u9009_u62E9_u7B26"><a href="#u4E0D_u8981_u9650_u5B9A_ID__u9009_u62E9_u7B26" class="headerlink" title="不要限定 ID 选择符"></a>不要限定 ID 选择符</h3><p>在页面中一个指定的 ID 只对应一个元素，没有必要添加额外的选择符</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="id">#header</span><span class="rules">&#123;&#125;</span> <span class="comment">/* 这样是没必要的，应该简化为 #header */</span></span><br></pre></td></tr></table></figure>
<h3 id="u4E0D_u8981_u9650_u5B9A_u7C7B_u9009_u62E9_u7B26"><a href="#u4E0D_u8981_u9650_u5B9A_u7C7B_u9009_u62E9_u7B26" class="headerlink" title="不要限定类选择符"></a>不要限定类选择符</h3><p>不要用具体的标签限定类选择符，而是根据实际情况对累名进行扩展。例如，把 li.item 改成 .li-item</p>
<h3 id="u8BA9_u89C4_u5219_u8D8A_u5177_u4F53_u8D8A_u597D"><a href="#u8BA9_u89C4_u5219_u8D8A_u5177_u4F53_u8D8A_u597D" class="headerlink" title="让规则越具体越好"></a>让规则越具体越好</h3><p>不要编写 ul li a 这样的长选择符，最好是创建一个像 .li-item 这样的类，并把它添加到适当的元素上</p>
<h3 id="u907F_u514D_u4F7F_u7528_u540E_u4EE3_u9009_u62E9_u7B26"><a href="#u907F_u514D_u4F7F_u7528_u540E_u4EE3_u9009_u62E9_u7B26" class="headerlink" title="避免使用后代选择符"></a>避免使用后代选择符</h3><p>通常处理后代选择符的开销是最高的，而是用梓煊泽肤也可以得到想要的结果，并且更高效。</p>
<h3 id="u907F_u514D_u4F7F_u7528_u6807_u7B7E_uFF0D_u5B50_u9009_u62E9_u7B26"><a href="#u907F_u514D_u4F7F_u7528_u6807_u7B7E_uFF0D_u5B50_u9009_u62E9_u7B26" class="headerlink" title="避免使用标签－子选择符"></a>避免使用标签－子选择符</h3><p>如果有像 #header &gt; li &gt; a 这样的基于标签的子选择符，那么应该使用一个类来关联每个标签元素。</p>
<h3 id="u8D28_u7591_u5B50_u9009_u62E9_u7B26_u7684_u6240_u6709_u7528_u9014"><a href="#u8D28_u7591_u5B50_u9009_u62E9_u7B26_u7684_u6240_u6709_u7528_u9014" class="headerlink" title="质疑子选择符的所有用途"></a>质疑子选择符的所有用途</h3><p>检查所有使用子选择符的地方，然后尽可能用具体的类取代它们。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>样式系统从最右边的选择符开始向左边匹配规则。只要当前选择符的左边还有其他的选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。</p>
<h2 id="u6700_u53F3_u8FB9_u4F18_u5148"><a href="#u6700]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
</feed>
