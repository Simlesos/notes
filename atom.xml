<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[莫声谷]]></title>
  <subtitle><![CDATA[突然想到你，笑了笑自己]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://imhzq.com/"/>
  <updated>2016-02-28T05:58:49.000Z</updated>
  <id>http://imhzq.com/</id>
  
  <author>
    <name><![CDATA[sumizu]]></name>
    <email><![CDATA[simlesos@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[js设计模式之策略模式]]></title>
    <link href="http://imhzq.com/2016/01/22/20160122_gof-for-js-strategy/"/>
    <id>http://imhzq.com/2016/01/22/20160122_gof-for-js-strategy/</id>
    <published>2016-01-21T16:00:00.000Z</published>
    <updated>2016-02-28T05:58:49.000Z</updated>
    <content type="html"><![CDATA[<p>厂家倒闭,原价 100元, 200元,300元的包包,现在全部50元,全部50元!</p>
<h2 id="u7B56_u7565_u6A21_u5F0F"><a href="#u7B56_u7565_u6A21_u5F0F" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>策略模式: 它定义了算法家族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化,不会影响到使用算法的客户.</p>
</blockquote>
<p>换句话说,策略模式就是定义一系列算法的方法,所有的算法都是用来完成相同的工作,只是实现不同,它可以以相同的方式调用所有的算法,减少了各种算法类与使用算法类之间的耦合.</p>
<h2 id="u5546_u573A_u6253_u6298"><a href="#u5546_u573A_u6253_u6298" class="headerlink" title="商场打折"></a>商场打折</h2><p>某家商场搞活动,周一正常收费,周二消费满300元减100元,周六日消费500元(包括)以上打8折!用代码实现这段代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var getCash = function(day, money)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (day)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> money;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(money &gt;= <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> money - <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">            <span class="keyword">if</span>(money &gt;= <span class="number">500</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> money * <span class="number">0.8</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码绝对可以满足需求,手工回家啦!又过了一周,商场周三也要加一个消费满999打7折的活动,这时候又要去修改 getCash 函数了,这违反了我们的开放封闭原则,我们来看看策略模式下的代码是怎么样的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strategy = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(money &gt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> money - <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">3</span>: <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(money &gt;= <span class="number">999</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> money * <span class="number">0.7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">6</span>: <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(money &gt;= <span class="number">500</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> money * <span class="number">0.8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">7</span>: <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">6</span>](money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getCash = <span class="function"><span class="keyword">function</span>(<span class="params">day, money</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strategy[day](money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCash(<span class="number">7</span>, <span class="number">500</span>)); <span class="comment">//=&gt; 400</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们就完成了一个最简单的策略模式的编写, getCash 本身并没有计算价格的能力,而是把计算委托给了策略对象,新增策略也只需要修改策略对象,无需去修改 getCash, 代码显得更加清晰,各个对象的职责更加清晰.</p>
<h2 id="u8868_u5355_u9A8C_u8BC1"><a href="#u8868_u5355_u9A8C_u8BC1" class="headerlink" title="表单验证"></a>表单验证</h2><p>在网页制作中,注册,登录等各种操作都离不开表单提交,在提交之前通常需要进行表单验证操作,假设我们现在写一个登录表单,需要验证几条逻辑:</p>
<ol>
<li>用户名不能为空</li>
<li>密码长度不能少于6为</li>
<li>手机号码必须符合格式</li>
</ol>
<p>我们来个反模式:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"http://xyy.com/register"</span> <span class="attribute">method</span>=<span class="value">"post"</span> <span class="attribute">id</span>=<span class="value">"registerForm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"uid"</span>&gt;</span>账号:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"uid"</span> <span class="attribute">id</span>=<span class="value">"uid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"pwd"</span>&gt;</span>密码:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"password"</span> <span class="attribute">name</span>=<span class="value">"pwd"</span> <span class="attribute">id</span>=<span class="value">"pwd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"phoneNumber"</span>&gt;</span>手机号码:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"phoneNumber"</span> <span class="attribute">id</span>=<span class="value">"phoneNumber"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">'registerForm'</span>);</span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(registerForm.uid.value === <span class="string">''</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户名不能为空'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(registerForm.pwd.value.length &lt; <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'密码长度小于 6 位'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/^1[3|5|8]\d&#123;9&#125;$/</span>.test(registerForm.phoneNumber.value))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请输入正确的手机号码'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能很多人都会写出这样的代码,这段代码的缺点和上面超市活动的例子一样,submit事件中包含了大量的 if-else 语句,如果需要新增加一种规则,或者密码长度要求改成8位,那么你就需要去神曲 submit 事件的代码中去修改他们,这违反了开放封闭原则,并且算法可复用性差,比如另一个项目中的表单也需要同样的验证方式,那么就需要复制来复制去了…</p>
<h2 id="u7528_u7B56_u7565_u6A21_u5F0F_u91CD_u6784_u8868_u5355_u9A8C_u8BC1"><a href="#u7528_u7B56_u7565_u6A21_u5F0F_u91CD_u6784_u8868_u5355_u9A8C_u8BC1" class="headerlink" title="用策略模式重构表单验证"></a>用策略模式重构表单验证</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strateiges = &#123;</span><br><span class="line">	isNonEmpty: <span class="function"><span class="keyword">function</span>(<span class="params">value, fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value === <span class="string">""</span>)&#123;</span><br><span class="line">			fn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	minLength: <span class="function"><span class="keyword">function</span>(<span class="params">value, length, fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value.length &lt; length)&#123;</span><br><span class="line">			fn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	maxLength: <span class="function"><span class="keyword">function</span>(<span class="params">value, length, fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value.length &gt; length)&#123;</span><br><span class="line">			fn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	regex: <span class="function"><span class="keyword">function</span>(<span class="params">value, regex, fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regex);</span><br><span class="line">		<span class="keyword">if</span>(!regex.test(value))&#123;</span><br><span class="line">			fn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> VForm = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.cache = [];</span><br><span class="line">&#125;</span><br><span class="line">VForm.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">dom, rule, fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.cache.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> args = rule.split(<span class="string">":"</span>);</span><br><span class="line">		<span class="keyword">var</span> strategy = args.shift();</span><br><span class="line">		args.unshift(dom.value);</span><br><span class="line">		args.push(fn);</span><br><span class="line">		strateiges[strategy].apply(dom, args);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VForm.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, validatorFunc; validatorFunc = <span class="keyword">this</span>.cache[i++];)&#123;</span><br><span class="line">		validatorFunc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> vform = <span class="keyword">new</span> VForm();</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.querySelector(<span class="string">"#registerFrom"</span>);</span><br><span class="line">vform.add(form.userName,<span class="string">"minLength:5"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"用户姓名长度不够！"</span>);</span><br><span class="line">&#125;).add(form.password, <span class="string">"maxLength:3"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"密码超长！"</span>);</span><br><span class="line">&#125;).add(form.phoneNumber, <span class="string">"regex:/^1[3][5][8]\d&#123;9&#125;$/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"请输入正确的电话号码！"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">form.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	e.preventDefault();</span><br><span class="line">	vform.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用策略模式后,我们仅需要维护一个验证函数的集合即可,这些验证函数可以复用在别的地方,甚至作为插件用在其他项目中.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>策略模式利用组合,委托,多态等技术,可以有效的避免多重条件选择语句.策略模式将算法单独封装在一个策略对象中,易于切换,易于理解,易于扩展.封装的算法又可以复用在其他地方,避免复制自己.</p>
<p>在js中策略模式是隐形的,因为函数被当做一等公民,函数可以被当做参数传递,很多时候策略模式在js中看起来就像是简单的传递参数.不过这不妨碍我们去了解学习策略模式!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>厂家倒闭,原价 100元, 200元,300元的包包,现在全部50元,全部50元!</p>
<h2 id="u7B56_u7565_u6A21_u5F0F"><a href="#u7B56_u7565_u6A21_u5F0F" class="headerlink" titl]]>
    </summary>
    
      <category term="GOF" scheme="http://imhzq.com/tags/GOF/"/>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js设计模式之代理模式]]></title>
    <link href="http://imhzq.com/2016/01/17/20160118_gof-for-js-proxy/"/>
    <id>http://imhzq.com/2016/01/17/20160118_gof-for-js-proxy/</id>
    <published>2016-01-16T16:00:00.000Z</published>
    <updated>2016-02-27T16:15:11.000Z</updated>
    <content type="html"><![CDATA[<p>乱哄哄，你方唱罢我登场，反认他乡是故乡；甚荒唐，到头来都是为他人作嫁衣裳。</p>
<h2 id="u4EE3_u7406_u6A21_u5F0F"><a href="#u4EE3_u7406_u6A21_u5F0F" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>为对象提供一种代理以控制这个对象的访问.</p>
</blockquote>
<p>公司BOSS需要定期检查项目进度,但是他并不会直接问你,而是让你的小组长去问你,小组长询问进度,问完后,将报告给交给BOSS.你的小组长在这个过程中就是代理.换句话说,在请求中当本体对象不方便直接回应的时候,提供一个代理对象来控制对这个对象的访问,代理对象对请求作出一些处理后,再把请求转交给本体对象.这就是代理模式的意义.</p>
<h2 id="u8001_u677F_u7EC4_u957F_u548C_u4F60"><a href="#u8001_u677F_u7EC4_u957F_u548C_u4F60" class="headerlink" title="老板组长和你"></a>老板组长和你</h2><p>我们试着来用代码来实现以下上面的例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Report = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问者</span></span><br><span class="line"><span class="keyword">var</span> boss = &#123;</span><br><span class="line">    checkProject: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.submitReport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="keyword">var</span> leader = &#123;</span><br><span class="line">    submitReport: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        laoZhang.submitReport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本体对象</span></span><br><span class="line"><span class="keyword">var</span> laoZhang = &#123;</span><br><span class="line">    submitReport: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> report = <span class="keyword">new</span> Report(<span class="string">'xxx项目报告'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'提交报告:'</span> + report.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss.checkProject(leader); <span class="comment">//=&gt; 提交报告: <span class="label">xxx项目报告</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里我们就完成了一个简单的代理模式,但是这里 leader 什么都没做,只是简单的把老张的报告交上去.现在我们来考虑一种情况,当boss 问老张要报告的时候,老张此时正在为解决一个BUG搞的焦头烂额,此时再让老张交个报告,老张肯定会爆炸的,报告做的不好,老张说不定就会被开除,这时候加入一个代理对象 leader 来随时监听老张是否空闲,就可以避免在老张忙碌的时候去打扰他,我们修改上面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Report = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> boss = &#123;</span><br><span class="line">    checkProject: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.submitReport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> leader = &#123;</span><br><span class="line">    submitReport: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        laoZhang.listenState(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            laoZhang.submitReport();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> laoZhang = &#123;</span><br><span class="line">    submitReport: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> report = <span class="keyword">new</span> Report(<span class="string">'xxx项目报告'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'提交报告:'</span> + report.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    listenState: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn();</span><br><span class="line">        &#125;,<span class="number">5000</span>); <span class="comment">//假设5秒后老张有空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss.checkProject(leader);  <span class="comment">//=&gt; 5s 后输出 <span class="label">xxx项目报告</span></span></span><br></pre></td></tr></table></figure>
<h2 id="u4EE3_u7406_u6A21_u5F0F_u5206_u7C7B"><a href="#u4EE3_u7406_u6A21_u5F0F_u5206_u7C7B" class="headerlink" title="代理模式分类"></a>代理模式分类</h2><p>一般来说代理模式分为<code>远程代理</code>,<code>虚拟代理</code>,<code>安全代理</code></p>
<ul>
<li><code>远程代理</code>: 远程代理就是为一个对象在不同的地址空间提供据局部代表,这样可以隐藏一个对象存在于不同地址空间的事实.举个栗子,C#的 WebService 添加时,会在项目中生成一个 WebReference 文件夹,其实它就是代理.</li>
<li><code>虚拟代理</code>: 虚拟代理是根据需要创建开销很大的对象,通过它来存放实例化需要很长时间的真实对象.举个栗子,我们经常会让一些比较大的图片在加载完成前,先用一张默认的图片放上去替代,等图片资源加载完了,再替换回来,这里我们的默认图片就是虚拟代理,虚拟代理中存储了真实的图片大小和路径</li>
<li><code>安全代理</code>:安全代理是用来控制真实对象的访问权限.一般用于对象应该有不同的访问权限的时候.</li>
</ul>
<h2 id="u865A_u62DF_u4EE3_u7406_u5E94_u7528"><a href="#u865A_u62DF_u4EE3_u7406_u5E94_u7528" class="headerlink" title="虚拟代理应用"></a>虚拟代理应用</h2><p>代理模式可以做很多事情,在js中我们比较常用的石 <code>虚拟代理</code>.我们用代码来实现一下上面提到的默认图片加载的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">'image'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> proxyImgNode = <span class="keyword">new</span> Image;</span><br><span class="line">    proxyImgNode.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        image.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            image.setSrc(<span class="string">'默认图片地址'</span>)</span><br><span class="line">            proxyImgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(<span class="string">'真实图片地址'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过 proxyImage 代理对象来访问 image,并在代理对象中加入了一些额外的操作,将在真正的图片加载完成前,先给 image 加载一个默认的图片.</p>
<h2 id="u8FD9_u4E48_u505A_u6709_u4F55_u610F_u4E49"><a href="#u8FD9_u4E48_u505A_u6709_u4F55_u610F_u4E49" class="headerlink" title="这么做有何意义"></a>这么做有何意义</h2><p>确实,上面的代码即使不用代理模式也都能实现. 但是这并不符合我们的程序设计思想<code>单一职责原则</code>和<code>封闭开放原则</code>,比如说上面图片的例子中,如果我们不需要默认图片加载了,那我们直接将代理对象切换成正常对象就可以了,而不适用代理模式的话,你就需要直接修改代码去删掉一些内容了.可以说,所有的设计模式都是为了保证我们的设计原则下才被写出来的,使用的时候不可本末倒置.</p>
<h2 id="u5176_u4ED6_u7684_u4EE3_u7406_u6A21_u5F0F"><a href="#u5176_u4ED6_u7684_u4EE3_u7406_u6A21_u5F0F" class="headerlink" title="其他的代理模式"></a>其他的代理模式</h2><p><code>javascript语言精粹</code>第 43 页讲了一种记忆函数,其实就是一种缓存代理.我们来用代理模式实现以下 Fibonacci 数计算的函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> memoizer = <span class="function"><span class="keyword">function</span> (<span class="params">memo, formula</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n] ? memo[n] : memo[n] = formula.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxyFibonacci = memoizer([<span class="number">0</span>,<span class="number">1</span>],fibonacci);</span><br><span class="line">proxyFibonacci(<span class="number">10</span>); <span class="comment">//=&gt;55</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>代理模式其实就是在访问对象时引入一定程度的间接性,因为这种间接性,可以附加多种用途!代理模式有很多类型,在 js 开发中,常见的就是虚拟代理和缓存代理,我在写代码的时候不必直接去猜测该不该用代理模式,而是当不放访问某个对象时,再上代理模式即可.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>乱哄哄，你方唱罢我登场，反认他乡是故乡；甚荒唐，到头来都是为他人作嫁衣裳。</p>
<h2 id="u4EE3_u7406_u6A21_u5F0F"><a href="#u4EE3_u7406_u6A21_u5F0F" class="headerlink" title="代]]>
    </summary>
    
      <category term="GOF" scheme="http://imhzq.com/tags/GOF/"/>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js设计模式之单例模式]]></title>
    <link href="http://imhzq.com/2016/01/17/20160117_gof_for_js_single/"/>
    <id>http://imhzq.com/2016/01/17/20160117_gof_for_js_single/</id>
    <published>2016-01-16T16:00:00.000Z</published>
    <updated>2016-02-27T16:15:11.000Z</updated>
    <content type="html"><![CDATA[<p>生还是不生,自己决定吧!</p>
<h2 id="u5355_u4F8B_u6A21_u5F0F"><a href="#u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>保证一个类仅有一个实例,并提供一个访问它的全局访问点.</p>
</blockquote>
<p>单例模式是一种常用的模式,有时候一些对象我们仅仅只要一个,比如,当我点击页面的按钮时,弹出一个登陆框,而且登陆框是唯一的,无论点击多少次登陆框,这个登陆框都只会出现一次,那么这个登陆框创建的代码就适合使用单例模式.</p>
<h2 id="u9762_u5411_u5BF9_u8C61_u7684_u5B9E_u73B0_u65B9_u5F0F"><a href="#u9762_u5411_u5BF9_u8C61_u7684_u5B9E_u73B0_u65B9_u5F0F" class="headerlink" title="面向对象的实现方式"></a>面向对象的实现方式</h2><p>要实现单例模式,只需要用一个变量来保存某个对象,在获取时检查是否存在这个对象,如果有就返回这个对象,如果没有就重新创建一个.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = <span class="keyword">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> d1 = CreateDiv.getInstance(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = CreateDiv.getInstance(<span class="string">'d2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d1 === d2); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>这里我们使用了 getInstance 来获取单例对象,也就是说,用户必须提前知道这个类是个单例类,有个 getInstance 方法获取单例,这明显不符合我们的最少知识原则.举个例子,现在国家开放二胎,那么到底你能不能生,国家并不知道,只有你自己知道能不能生二胎,所以,生不生,还是自己决定吧!</p>
<p>现在我们将”生不生”的权利交给对象自己:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance) <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="keyword">this</span>.html = html;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        div.innerHTML = <span class="keyword">this</span>.html;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> CreateDiv(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> CreateDiv(<span class="string">'d2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(d1 === d2); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>
<p>现在生不生的权利到对象自己手中了,但是这段代码的问题还是很大的,我们为了实现一个保存点,创建了一个IIFE来包裹整个对象,这无形中,增加了代码的复杂度,一点都不优美!!</p>
<h2 id="u7528_u4EE3_u7406_u6A21_u5F0F_u5B9E_u73B0_u5355_u4F8B_u6A21_u5F0F"><a href="#u7528_u4EE3_u7406_u6A21_u5F0F_u5B9E_u73B0_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="用代理模式实现单例模式"></a>用代理模式实现单例模式</h2><p>虽然我们还没讲代理模式是什么鬼,但是大丈夫!下面的代码很简单:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = <span class="keyword">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ProxySingletonCreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">'d2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d1 === d2);</span><br></pre></td></tr></table></figure></p>
<p>CreateDiv 类的本体不改动,该怎么用还怎么用,我们通过一个代理类 ProxySingletonCreateDiv 来单独实现单例模式.现在看起来是不是比较干净整洁了!而且分开管理了创建和单例管理!</p>
<h2 id="u95ED_u5305_u7248_u672C_u7684_u5355_u4F8B_u6A21_u5F0F"><a href="#u95ED_u5305_u7248_u672C_u7684_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="闭包版本的单例模式"></a>闭包版本的单例模式</h2><p>js中没有类的概念,我们上面只是模拟 C#/Java 的操作,其实没有必要使用”类”,闭包就能实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  createDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            instance.innerHTML = html;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = createDiv(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = createDiv(<span class="string">'d2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d1 === d2); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u901A_u7528_u7684_u61D2_u6C49_u5F0F_u5355_u4F8B_u6A21_u5F0F"><a href="#u901A_u7528_u7684_u61D2_u6C49_u5F0F_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="通用的懒汉式单例模式"></a>通用的懒汉式单例模式</h2><p>单例模式可以人为的分为,<code>饿汉单例</code>和<code>懒汉单例</code>,顾名思义, <code>饿汉单例</code>会在代码加载阶段就创建出对象,所以要提前占用系统资源,<code>懒汉单例</code>则是用到时再去初始化,根据业务需求,选择对应的即可,这里我们实现一个通用的懒汉单例提供参考:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用单例模式</span></span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance || (instance = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createSingleDiv = getSingle(createDiv);</span><br><span class="line"><span class="keyword">var</span> d1 = createSingleDiv(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = createSingleDiv(<span class="string">'d2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d1 === d2); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>我们把创建对象的方法和管理单例的职责分别放在两个函数中,这两个函数互不影响,可以独立变化,当它们一起用用时,就组合成了创建唯一实例的功能,代码之美,就是这样啊!</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>单例模式是一种很简单,但是非常实用的设计模式,最佳实现是把对象的创建和单例管理分开管理,互不干扰,合起来又能创建唯一对象,真的是非常棒!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>生还是不生,自己决定吧!</p>
<h2 id="u5355_u4F8B_u6A21_u5F0F"><a href="#u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="单例模式"></a>单例模式</h2><blockq]]>
    </summary>
    
      <category term="GOF" scheme="http://imhzq.com/tags/GOF/"/>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS模块化历程]]></title>
    <link href="http://imhzq.com/2016/01/15/20160115_js_module/"/>
    <id>http://imhzq.com/2016/01/15/20160115_js_module/</id>
    <published>2016-01-14T16:00:00.000Z</published>
    <updated>2016-02-26T09:48:50.000Z</updated>
    <content type="html"><![CDATA[<p>在ES6 之前的 js 中,并没有像 java 的 import, C# 的 using, css 的 @import 这种类似的语言支持的模块系统.</p>
<h2 id="u6A21_u5757_u662F_u4EC0_u4E48_3F"><a href="#u6A21_u5757_u662F_u4EC0_u4E48_3F" class="headerlink" title="模块是什么?"></a>模块是什么?</h2><p>模块要实现的基本功能包块下面三点:</p>
<ol>
<li>封装实现</li>
<li>暴漏接口</li>
<li>依赖声明</li>
</ol>
<h2 id="u65E9_u671F_u7684_u65E0_u6A21_u5757"><a href="#u65E9_u671F_u7684_u65E0_u6A21_u5757" class="headerlink" title="早期的无模块"></a>早期的无模块</h2><p>我们一步一步来看,最早期的时候,假如有这么一段代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> _max = <span class="number">10</span>; <span class="comment">//直接暴漏私有变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> random(_max + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中, b.js 依赖 a.js,但是却没有显式的依赖关系,完全凭程序员的自觉,并且两个js文件中的函数都是暴漏在全局环境中.显然这并不能满足我们的需求.</p>
<h2 id="u5BF9_u8C61_u5B57_u9762_u91CF_u5305_u88C5"><a href="#u5BF9_u8C61_u5B57_u9762_u91CF_u5305_u88C5" class="headerlink" title="对象字面量包装"></a>对象字面量包装</h2><p>我们对上面的代码稍作改进<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        random: random</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random(_max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getNumber: getNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样看起来代码更具有结构性, b.js 中得私有变量 _max 也成功的被隔离在闭包中,成为私有成员,外界无法访问.并且每个js文件只暴漏了一个全局变量.这种模式在javascript中被称为模块暴漏.看起来这段代码似乎改善了一些问题,但是这远远没有达到我们的需求,依赖声明问题依然没有解决.</p>
<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>我们需要一个显式的依赖声明,可以通过 IIFE(Immediately Invoked Function Expression),函数被包含在一对()内,就成为一个表达式,通过在末尾加上另一个()就可以立即执行这个函数,这就是 <code>立即执行函数表达式</code>, 我们将上面的代码改成这种来看看<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        random: random</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.random(_max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getNumber: getNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(a);</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过 IIFE 将 a.js 和 b.js包裹在一个闭包中,我们不需要再去额外的调用a,b函数来获取暴漏接口,并在 b.js中显式的声明了依赖关系,但是依然没有依赖控制,仍然污染了全局变量.</p>
<h2 id="u547D_u540D_u7A7A_u95F4_u5F0F_u7684_u6A21_u5757"><a href="#u547D_u540D_u7A7A_u95F4_u5F0F_u7684_u6A21_u5757" class="headerlink" title="命名空间式的模块"></a>命名空间式的模块</h2><p>我们可以定义一个模块加载器,核心代码如下:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span><span class="params">(name, deps, impl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++)&#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>我们把所有模块都存放在 modules 列表中,并且统一管理依赖关系,使用起来如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MyModules.defined(<span class="string">'a'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        random: random</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyModules.defined(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.random(_max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getNumber: getNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = MyModules.get(<span class="string">'b'</span>);</span><br><span class="line">b.getNumber(); <span class="comment">//=&gt; some number</span></span><br></pre></td></tr></table></figure></p>
<p>熟悉 AMD 的朋友看起来一定不会陌生?这种命名空间的方式显式声明了依赖关系,并且完全消除了对全局环境的污染,但是依赖管理上还是有问题,如果 a, b 模块定义在不同 js 文件中,那么还是需要人为的去控制 a.js 和 b.js 的引用顺序,简单的还好说,如果有十几个复杂的依赖关系,组成一条依赖链,人力根本无法处理如此复杂的关系网</p>
<h2 id="u6A21_u5757_u7CFB_u7EDF"><a href="#u6A21_u5757_u7CFB_u7EDF" class="headerlink" title="模块系统"></a>模块系统</h2><p>模块系统最重要的功能就是依赖管理,包含了 <code>加载</code>,<code>分析</code>, <code>注入</code> <code>初始化</code>这四个最主要的功能,同时不同的模块系统有着不同的模块写法.</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS 主要被用作非浏览器环境中的模块化,但是通过 <a href="http://browserify.org/" target="_blank" rel="external">browserify</a> 或者 <a href="https://webpack.github.io/" target="_blank" rel="external">webpack</a> 也可以在浏览器中使用. 大名鼎鼎的 node.js 中的模块化就使用的 CommonJS. 举个栗子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">&#125;</span><br><span class="line">exports.random = random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'/a'</span>); <span class="comment">// 依赖声明</span></span><br><span class="line"><span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.random(_max + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.getNumber = getNumber;</span><br></pre></td></tr></table></figure></p>
<p>CommonJS社区活跃度很高,规范接受度也非常高,是运行时支持的,作用域基于文件,一个文件就是一个模块.但是因为使用了同步的 require,没有考虑浏览器环境,在浏览器下无法直接使用.</p>
<blockquote>
<p>   优点:<br>       依赖管理成熟可靠<br>       社区活跃,规范接受度高<br>       运行时支持,模块定义非常简单<br>       文件级的模块作用域隔离<br>   缺点:<br>       不是标准组织的规范<br>       同步 require,没有考虑浏览器环境</p>
</blockquote>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>由于CommonJS没有考虑异步使用情况,于是就有了 AMD(Asynchronous Module Definition) 规范.比较有名的就是 <a href="http://requirejs.org/" target="_blank" rel="external">requireJS</a>,AMD 使用起来和我们上面所讲的命名空间型的模块定义及其相似<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line">define([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; random: random &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line">define([<span class="string">'/a'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.random(_max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; getNumber: getNumber&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>虽然写法上很相似,但是区区十几行的命名空间模块显然无法和 AMD 相提并论, 最大的区别就是依赖管理.</p>
<p>另外 AMD 还有种 Simplified CommonJS wrapping 的写法,可以和 CommonJS的写法很相似<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    <span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.random(_max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exports.getNumber = getNumber;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这种写法其实还是依赖前置(通过正则匹配等方式),并不是类似于 Seajs 的 CMD那样依赖后置,只是写法上的类似. </p>
<blockquote>
<p>   优点:<br>       依赖管理成熟可靠<br>       社区活跃,规范接受度高<br>       专为异步IO环境打造,适合浏览器环境<br>       支持类似 Commonjs 的书写方式<br>       通过 load plug 可以支持加载非 js 资源<br>       成熟的打包工具,并可结合插件使用<br>   缺点:<br>       模块定义繁琐,需要额外嵌套<br>       只是库级别的支持,需要引入额外库<br>       无法处理循环依赖<br>       无法实现条件加载</p>
</blockquote>
<h2 id="JS_u8BED_u8A00_u7EA7_u522B_u7684_u6A21_u5757_u5316_26gt_3B"><a href="#JS_u8BED_u8A00_u7EA7_u522B_u7684_u6A21_u5757_u5316_26gt_3B" class="headerlink" title="JS语言级别的模块化&gt;"></a>JS语言级别的模块化&gt;</h2><p>新的 ES 规范中,出现了JS语言级别的模块化:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> random(number)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">var</span> _max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.random(_max + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>   优点:<br>       真正的规范,模块化的标准<br>       语言级别的关键字支持<br>       适应所有 javascript 运行时,包括浏览器<br>       支持循环依赖<br>   缺点:<br>       规范未达到稳定级别<br>       基本还没有浏览器支持</p>
</blockquote>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们首先引入了 IIFE,然后加入了命名空间,但是核心的依赖分析和注入没有实现,于是出现了 AMD, Commonjs, ES6 这些新秀,他们之间也可以通过一些库来实现相互转换,比如 <a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">system.js</a>,按需使用. 模块化使得js具备开发大型应用的能力,而不是停留在小脚本程序的阶段.当然也离不开标准的制定.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在ES6 之前的 js 中,并没有像 java 的 import, C# 的 using, css 的 @import 这种类似的语言支持的模块系统.</p>
<h2 id="u6A21_u5757_u662F_u4EC0_u4E48_3F"><a href="#u6A21]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="模块化" scheme="http://imhzq.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[修改js词法作用域的几种方式]]></title>
    <link href="http://imhzq.com/2016/01/13/20160113_js_cheat_scope/"/>
    <id>http://imhzq.com/2016/01/13/20160113_js_cheat_scope/</id>
    <published>2016-01-12T16:00:00.000Z</published>
    <updated>2016-02-25T14:45:04.000Z</updated>
    <content type="html"><![CDATA[<p>js中的作用域是词法作用域,也就是完全由编写代码期间函数的位置决定,那能不能人为的修改,创建作用域那?当然是可以的.</p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>虽然 with 已经被弃用,但是了解一下又不会怀孕~ with可以在当前作用域中以传入的对象为基础,创建出一个新的作用域,但是要小心很多坑,看下面这段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj)&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; a: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; b: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fn(o1)); <span class="comment">//=&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(o2)); <span class="comment">//=&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(o1.a);  <span class="comment">//=&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.a);  <span class="comment">//=&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//=&gt; 2</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码中o1有a属性,o2没有a属性,fn函数中接收一个obj参数,在函数中对这个obj对象执行了with,在with块内部,我们对变量a进行简单的此法引用.</p>
<p>这里大家比较有疑问的地方可能是 o2.a 为什么是 undefined,为什么全局对象上多了一个 a 属性?既然说with创建出一个新的作用域,为什么在with块内声明的 c ,还能在外部访问到? 别急,我们一个一个来说.</p>
<p>这段代码中 o1 因为其中有 a 属性,所以LHS找到了 a,并成功赋值成功,而 o2 中并没有 a 属性,因此并不会创建这个属性,所以 o2.a 是 undefined. with创建出的作用域和一般的作用域也是一样的,如果LHS在一层层的作用域中都找不到 a,则会在全局中创建出一个 a,也是就 window 对象上创建出一个 a属性,并赋值为2. </p>
<p>那么 c 为什么能被外部的块访问到那,这是因为 with块虽然可以将一个对象处理为词法作用域,但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中,而是被添加到 with 所处的函数作用域中.</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>eval 可以动态的修改当前作用域,在执行 eval 时,它可以将你写在其中的字符串当做代码,并把这段代码当做就像写在程序中那个位置中一样,就是说,你在 eval 中写的代码,就好像本来就写在那个位置上一样.但同样也有许多坑,来看看下面这个例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'this.a=2'</span>); <span class="comment">//修改当前作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f1.a); <span class="comment">//=&gt; 2;</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码中 eval 对 fn 的词法作用域进行了修改,动态的为 f1 创建除了 a 属性,但有一种特殊情况,如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    e(<span class="string">'this.a=2'</span>); <span class="comment">//修</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f1.a); <span class="comment">//=&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 2;</span></span><br></pre></td></tr></table></figure></p>
<p>这里把 eval 函数赋值给一个变量后, eval 中得 this 指向不再是当前函数中得this,而是全局对象.</p>
<p>eval 还有一个有趣的事情是, eval中得代码不会发生提升,可以试试下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//==&gt; ReferenceError: a is not defined</span></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'var a = 1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<h2 id="try/catch"><a href="#try/catch" class="headerlink" title="try/catch"></a>try/catch</h2><p>try/catch 的 catch块可以创建出一个全新的词法作用域, js中虽然没有块级作用域,但是 catch块可以模拟,参考下面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(o)&#123;</span><br><span class="line">        o = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">//=&gt; ReferenceError: o is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>通过 try/catch 我们可以模拟块级作用域, 可以看到在 catch 块中声明的 b,在外部无法访问,值得注意的是 catch 块中也会有提升行为,并且把行为提升到 fn 作用域中.</p>
<p>熟悉 ES6 的同学,可能知道 let 操作符,可以声明块级作用域, 其实 try/catch 可以完美的模拟出 let. 在一些兼容方案中也是如此.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>with, eval, try/catch 都可以”欺骗”词法环境,但又有各自的缺陷, eval 和 with 因为安全性和性能问题,不推荐大家使用,而 try/catch 在模拟块级作用域,尤其是兼容 let 上还是很有用.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>js中的作用域是词法作用域,也就是完全由编写代码期间函数的位置决定,那能不能人为的修改,创建作用域那?当然是可以的.</p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6之let]]></title>
    <link href="http://imhzq.com/2016/01/12/20160112_js_es6_let/"/>
    <id>http://imhzq.com/2016/01/12/20160112_js_es6_let/</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2016-02-25T15:45:41.000Z</updated>
    <content type="html"><![CDATA[<p>如果以前说 js 中没有块级作用域的话, ES6 后就不能这么说了哦!</p>
<h2 id="u4EC0_u4E48_u662Flet"><a href="#u4EC0_u4E48_u662Flet" class="headerlink" title="什么是let"></a>什么是let</h2><p>let 是 ES6 中新增的关键字, 类似于 var 用来声明变量,但是所声明的变量只有在 let 所在块内有效.换句话说,let 声明的变量隐式地绑定在 let 的包含块中.let 需要在js的 <code>use strict</code> 模式下才能使用.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<h2 id="let_u4E0D_u4F1A_u6709_u63D0_u5347_u884C_u4E3A"><a href="#let_u4E0D_u4F1A_u6709_u63D0_u5347_u884C_u4E3A" class="headerlink" title="let不会有提升行为"></a>let不会有提升行为</h2><p>let 修饰的变量不会有提升行为,如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; ReferenceError</span></span><br><span class="line">        <span class="built_in">console</span>.log(b); <span class="comment">//=&gt; undefined</span></span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>因为没有了提升行为,导致的直接结果就是,let 所在的整个块中, let 声明之前,访问此变量都会发生 ReferenceError.</p>
<h2 id="let_u5FAA_u73AF"><a href="#let_u5FAA_u73AF" class="headerlink" title="let循环"></a>let循环</h2><p>let使用的典型痢疾就是绑定到 for 循环的块中<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var temps = [];</span><br><span class="line">function fn()&#123;</span><br><span class="line"><span class="code">    "use strict"</span></span><br><span class="line"><span class="code">    for(let i = 0; i &lt; 3; i++)&#123;</span></span><br><span class="line"><span class="code">        temps[i] = function()&#123;</span></span><br><span class="line"><span class="code">            console.log(i);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">temps[<span class="link_label">0</span>](<span class="link_url"></span>); //=&gt; 0</span><br><span class="line">temps[<span class="link_label">1</span>](<span class="link_url"></span>); //=&gt; 1</span><br><span class="line">temps[<span class="link_label">2</span>](<span class="link_url"></span>); //=&gt; 2</span><br></pre></td></tr></table></figure></p>
<p>如果不使用 let,按照以前的做法,我们会通过一个闭包,将每次循环的 i 保存下来,现在有了 let 就方便多了.</p>
<p>实际上 let 不仅将 i 绑定到了 for 循环的块中, 事实上它将其重新绑定到了循环中的每个迭代中, 确保使用上一个循环结束时的值重新进行赋值, 就好像 C#,java 中一样.看起来就像这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        let i = j;  <span class="comment">//每个迭代重新绑定</span></span><br><span class="line">        console.<span class="built_in">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="let_u4E0D_u5141_u8BB8_u91CD_u590D_u58F0_u660E"><a href="#let_u4E0D_u5141_u8BB8_u91CD_u590D_u58F0_u660E" class="headerlink" title="let不允许重复声明"></a>let不允许重复声明</h2><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>; <span class="comment">//ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6A21_u62DF_let"><a href="#u6A21_u62DF_let" class="headerlink" title="模拟 let"></a>模拟 let</h2><p>在不支持 ES6 的代理环境中,可以使用 try/catch 来模拟会计作用域,详情可以看 <code>修改js词法作用域那篇文章</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果以前说 js 中没有块级作用域的话, ES6 后就不能这么说了哦!</p>
<h2 id="u4EC0_u4E48_u662Flet"><a href="#u4EC0_u4E48_u662Flet" class="headerlink" title="什么是let"><]]>
    </summary>
    
      <category term="ES6" scheme="http://imhzq.com/tags/ES6/"/>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS中的提升]]></title>
    <link href="http://imhzq.com/2016/01/10/20160110_js_variable_up/"/>
    <id>http://imhzq.com/2016/01/10/20160110_js_variable_up/</id>
    <published>2016-01-09T16:00:00.000Z</published>
    <updated>2016-02-23T17:09:45.000Z</updated>
    <content type="html"><![CDATA[<p>离得越近,其实看见的越少  - 《惊天魔盗团》</p>
<h2 id="u63D0_u5347"><a href="#u63D0_u5347" class="headerlink" title="提升"></a>提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//=&gt; undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码大家都知道因为变量提升原因,执行起来是这样子的:<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span><span class="comment">&#123;</span><br><span class="line">    var a;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a = 2</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="title">fn</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>这看起来就好像函数和变量的声明被移动到了最上面,这就是<code>提升</code>,每个作用域都会提升,比如例子中的全局作用域和 fn函数作用域都发生了提升</p>
<h2 id="u51FD_u6570_u63D0_u5347"><a href="#u51FD_u6570_u63D0_u5347" class="headerlink" title="函数提升"></a>函数提升</h2><p>上面的例子可以看出,函数声明也会提升,那函数表达式那? 实践是检验真理的唯一标准, 一起来看看下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a(); <span class="comment">//=&gt; TypeError: a is not function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案是函数表达式不会提前.这段代码经过编译后的样子大概是这样的:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a();</span><br><span class="line">a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = argument.callee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u51FD_u6570_u4F18_u5148"><a href="#u51FD_u6570_u4F18_u5148" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明提升,谁优先? 老样子,还是来段代码就知道了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn(); <span class="comment">//=&gt;2</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数声明提升优先于函数表达式和变量声明,上面的代码编译后的样子大概是这个样子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** var fn; **/</span> <span class="comment">//当前作用域中已经声明了fn,所以该提升会被忽略</span></span><br><span class="line">fn();</span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里想必大家都清楚了提升问题,下面就来谈谈重点,为什么会有提升?</p>
<h2 id="u4E3A_u4EC0_u4E48_u4F1A_u6709_u63D0_u5347_u8FD9_u79CD_u73B0_u8C61_3F"><a href="#u4E3A_u4EC0_u4E48_u4F1A_u6709_u63D0_u5347_u8FD9_u79CD_u73B0_u8C61_3F" class="headerlink" title="为什么会有提升这种现象?"></a>为什么会有提升这种现象?</h2><p>说到提升现象,就不得不提作用域,js的作用域不同于JAVA,C#的动态作用域,而是词法作用域,在js执行前,会有一个编译阶段,其中有一步会先将我们的代码进行语法分析生成抽象语法树,然后基于语法树会生成相应的作用域对象,再找到所有的声明并分别与合适的作用域对象关联起来.这样的结果也就是js的作用域与执行的位置无关,只与定义的环境有关,也就是只与我们所写的位置有关,这也就是词法作用域了.</p>
<p>所以,我认为变量提升,就是js实现词法作用域的副产品.又或者说是词法作用域实现的一种方式.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>离得越近,其实看见的越少  - 《惊天魔盗团》</p>
<h2 id="u63D0_u5347"><a href="#u63D0_u5347" class="headerlink" title="提升"></a>提升</h2><figure class="highlight]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flex简明教程(二)]]></title>
    <link href="http://imhzq.com/2016/01/06/20160106_css_flex2/"/>
    <id>http://imhzq.com/2016/01/06/20160106_css_flex2/</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-02-22T16:44:10.000Z</updated>
    <content type="html"><![CDATA[<p>接上次flex的文章,这次我们讲 flex 剩下的两种属性-弹性属性和对其属性</p>
<h2 id="u5F39_u6027_u5C5E_u6027"><a href="#u5F39_u6027_u5C5E_u6027" class="headerlink" title="弹性属性"></a>弹性属性</h2><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>: 数字值,默认值为auto,设置 flex item 主轴(row/column)的最小宽/高,通常配合grow 和 shrink使用</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>: 数字值,默认值是0,设置扩展因子作为比率分配<code>剩余空间</code>,不能为负值<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/r3oq0xf5/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>flex-shrink</code>:数字值,默认值为1,设置的收缩因子作为比率来收缩<code>超出空间</code><br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/57pa5r1y/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>: 这个属性是 flex-grow, flex-shrink, flex-basis 的缩写形式,默认值为 1, 1, 0;</p>
<h2 id="u5BF9_u9F50_u5C5E_u6027"><a href="#u5BF9_u9F50_u5C5E_u6027" class="headerlink" title="对齐属性"></a>对齐属性</h2><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>: 定义主轴上的对齐方式。当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制。<br>justify-content: flex-start(默认值) | flex-end | center | space-between | space-around;<br>flex-start: 左/上对齐<br>flex-end: 右/下对齐<br>center: 居中对齐<br>space-between: flex item 的两端对其<br>space-around: 每个 flex item 的两端间隔相等, 此时flex item之间的间距将是两边flex item距离边框距离的两倍<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/wv3uLgem/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>: 定义辅轴方向上的对其方式.<br>align-items: flex-start | flex-end | center | baseline | stretch(默认值)<br>flex-start：弹性盒子元素的辅轴起始位置的边界紧靠住该行的侧轴起始边界。<br>flex-end：弹性盒子元素的辅轴起始位置的边界紧靠住该行的侧轴结束边界。<br>center：弹性盒子元素在该行的辅轴上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。<br>baseline：如弹性盒子元素的行内轴与辅轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。<br>stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/kn9yxLs2/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>: 定义flex item单独在辅轴方向上的对齐方式。<br>align-self：auto(默认) | flex-start | flex-end | center | baseline | stretch<br>参数和 <code>align-item</code> 一致,只是用来控制单个 flex item对象,可以参考<code>align-item</code></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>: 当伸缩容器的辅轴出现多行还有多余空间时，这个属性可以用来调准「伸缩行」在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的 <code>justify-content</code> 属性类似。请注意本属性在只有一行的伸缩容器上没有效果。<br>align-content：flex-start | flex-end | center | space-between | space-around | stretch(默认)<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/pgq68svy/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<p>到这里,flex属性已经讲完了,下一篇我们再来讲讲flex的应用!睡觉~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上次flex的文章,这次我们讲 flex 剩下的两种属性-弹性属性和对其属性</p>
<h2 id="u5F39_u6027_u5C5E_u6027"><a href="#u5F39_u6027_u5C5E_u6027" class="headerlink" title=]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flex简明教程(一)]]></title>
    <link href="http://imhzq.com/2016/01/05/20160105_css_flex1/"/>
    <id>http://imhzq.com/2016/01/05/20160105_css_flex1/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-02-22T16:44:10.000Z</updated>
    <content type="html"><![CDATA[<p>传统的 css 布局采用盒模型,通过一些列定位属性来布局,但是对于垂直居中,等分这类特殊情况处理起来就比较麻烦,虽然使用负外边距,table-cell等方式也能兼容实现,但是始终是一种 hack.</p>
<h2 id="u4EC0_u4E48_u662Fflex"><a href="#u4EC0_u4E48_u662Fflex" class="headerlink" title="什么是flex"></a>什么是flex</h2><p>flex 又称弹性盒布局,顾名思义,就是可以根据设定的拉伸和收缩因子拉伸或者收缩空间,写过 android 布局的同学是不是会想起来 <code>android:layout_weight</code>啊~,没错就是一个意思!</p>
<p>查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Browser_compatibility" target="_blank" rel="external">flex浏览器兼容性</a>,IE10+才支持不免有些丧气,不过移动端还是棒棒的~</p>
<h2 id="flex_u57FA_u672C_u8BED_u6CD5"><a href="#flex_u57FA_u672C_u8BED_u6CD5" class="headerlink" title="flex基本语法"></a>flex基本语法</h2><p>任何一个容器都能成为 flex 弹性盒:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;<span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;&#125;</span> </span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="tag">span</span><span class="rules">&#123;<span class="rule"><span class="attribute">display</span>:<span class="value"> inline-flex</span></span>;&#125;</span> <span class="comment">/* 行内元素也可以哦 */</span></span><br></pre></td></tr></table></figure></p>
<p>这样就把一个标准盒模型转变为弹性盒模型,其中仍在文档流中的直接子元素则变为 <code>flex item</code>,看下面这个例子:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- flex item：在文档流且为直接子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">'display:flex;'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span>block<span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">'float:left;'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span>&gt;</span>inline<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">'position:absolute;'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span> <span class="comment">&lt;!-- 不是，绝对定位脱离文档流 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 是 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span>inner<span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- 不是，不是直接子元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以把 flex 的属性分为三类, 方向属性,弹性属性和对齐属性, 这次我们先来讲方向属性</p>
<h3 id="u65B9_u5411_u5C5E_u6027"><a href="#u65B9_u5411_u5C5E_u6027" class="headerlink" title="方向属性"></a>方向属性</h3><p><code>flex-direction</code>: 决定<code>主轴</code>的方向<br>flex-direction: row(默认值) | row-reverse | column | column-reverse<br>row: 横向从左到右排列（左对齐）。<br>row-reverse: 对齐方式与row相反。<br>column: 纵向从上往下排列（顶对齐）。<br>column-reverse: 对齐方式与column相反。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/7zs2y50j/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<p><code>flex-wrap</code>:<br>flex-wrap: nowrap(默认值) | warp | wrap-reverse<br>nowrap：flex容器为单行,该情况下flex item可能会溢出容器<br>wrap：flex容器为多行,该情况下flex item溢出的部分会被放置到新行，子项内部会发生断行<br>wrap-reverse：反转 wrap 排列。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/rd276drv/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
<p><code>flex-flow</code>:<br>flex-flow: &lt;’flex-direction’ || flex-warp&gt;<br>上面两个属性的缩写形式</p>
<p><code>order</code>:<br>order: 整数类型, 默认值为 0<br>用整数值来定义排列顺序，数值小的排在前面,可以为负值。<br>例子:<br><iframe width="100%" height="300" src="http://jsfiddle.net/1vtujpmu/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>传统的 css 布局采用盒模型,通过一些列定位属性来布局,但是对于垂直居中,等分这类特殊情况处理起来就比较麻烦,虽然使用负外边距,table-cell等方式也能兼容实现,但是始终是一种 hack.</p>
<h2 id="u4EC0_u4E48_u662Fflex"><a ]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js基于时间的动画]]></title>
    <link href="http://imhzq.com/2016/01/01/20160101_js_animation/"/>
    <id>http://imhzq.com/2016/01/01/20160101_js_animation/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2016-02-21T15:11:25.000Z</updated>
    <content type="html"><![CDATA[<p>说起前端动画,不得不提CSS动画和JS动画,这里简单谈谈这两者.</p>
<p>CSS动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.<br>相比之JS动画则依托完备的编程语言,可以对动效的设计进行无限的控制,虽然编写起来相比CSS动画来说较为复杂,但可以通过一些第三方库来快速实现,比如 <a href="http://julian.com/research/velocity/" target="_blank" rel="external">VelocityJS</a> . 当然,事物的好坏永远需要按场景区分, CSS动画和JS动画也是如此,比如说一个简单的按钮 hover 效果,无论怎么看CSS动画都是第一选择,但是如果需要控制一个动画工作流,那JS动画一定更适合了. </p>
<p>有点跑题了…, 回到正文</p>
<h2 id="u5173_u952E_u5E27_u52A8_u753B"><a href="#u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><p>假如现在我们有这样一个需求 <code>让一个 div 向右边移动 300px 的距离</code>, 我们来看看下面这种实现<br><iframe width="100%" height="300" src="http://jsfiddle.net/dq7Ldctf/embedded/js,result/light" frameborder="0" allowfullscreen></iframe></p>
<p>看起来我们实现了这个需求,不过不要急,我们稍稍修改上面代码中的 step 函数,在其中加入这段代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">    <span class="keyword">while</span> ((+<span class="keyword">new</span> <span class="built_in">Date</span> - start) &lt; <span class="number">1000</span>)&#123;&#125; <span class="comment">//阻塞1s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家可以去 jsfiddle 中加入这段代码, 观察后,不难发现这个 div 在 left 值为 200px 的地方停顿了 1000+ms. 大家都知道js是基于事件模型的,我们在 step 函数中 setInterval 其实相当于告诉引擎,帮我在 16.7 毫秒后将这个回调函数加入事件队列,如果引擎空闲就执行,此时我们 while 循环1秒,就会阻塞整个事件队列的运行,也就阻塞了UI线程的渲染,表现出来结果就是我们的div运动停止了1秒多.</p>
<p>这里虽然是人为的加入了阻塞代码,但是在正常的开发过程中,setInterval 和 setTimeout 根本没法保证按我们要求的在固定的间隔执行事件,此时如果我们的动画还是按照 <code>变化量/帧</code> 的方式来执行,就会出现不同设备中动画执行时间不同的情况,在移动端是重灾区.</p>
<h2 id="u57FA_u4E8E_u65F6_u95F4_u7684_u52A8_u753B"><a href="#u57FA_u4E8E_u65F6_u95F4_u7684_u52A8_u753B" class="headerlink" title="基于时间的动画"></a>基于时间的动画</h2><p>在讨论上面所述的问题该如何解决之前,不妨先来看看这个数学题:</p>
<blockquote>
<p>A地和B地相距300m,一辆速度为 5m/s 匀速运动的自行车从A地出发去往B地,请问一分钟后自行车距离A地多远?</p>
</blockquote>
<p>我们用时间 时间 <em> 速度 即可得出 5 </em> 60 = 300,也就是300m, 从这个简单的问题中,我们可以发现我们不必去寄人篱下一帧帧的做动效,不必去管帧率的问题,我们可以从动画开始时间到当前时间计算出动画经过的时间,通过 时间 * 速度,计算出当前动画的偏移量,这样就可以保证我们所有性能的平台下动画都是一个速度进行着.下面我们来修改下上面的代码:<br><iframe width="100%" height="300" src="http://jsfiddle.net/rbdk6z79/embedded/js,result/light" frameborder="0" allowfullscreen></iframe></p>
<p>这里我们改为根据时间来计算偏移量,我的测试环境中弹出的结果应该在 <code>4801</code>,下面我们来看看加入同样阻塞代码后的用时,是不是也增加了1000毫秒那:<br><iframe width="100%" height="300" src="http://jsfiddle.net/2yr24asu/embedded/js,result/light" frameborder="0" allowfullscreen></iframe><br>我的测试环境弹出的石 <code>4865</code>,可以看出虽然加入了阻塞代码,但是因为我们是按照时间来计算偏移量的,所以动画总时间不会偏差过大,各个平台下动画也不会出现有的快有的慢得情况.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>基于时间的动效能够消除不同设备不同环境下动画帧数不同导致的动效速度不同的问题,推荐所有的动效都应该采用基于时间的方式!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起前端动画,不得不提CSS动画和JS动画,这里简单谈谈这两者.</p>
<p>CSS动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.<br>相比之JS]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS3动画-深夜恶搞]]></title>
    <link href="http://imhzq.com/2015/12/15/20151215_css_animation/"/>
    <id>http://imhzq.com/2015/12/15/20151215_css_animation/</id>
    <published>2015-12-14T16:00:00.000Z</published>
    <updated>2016-02-21T15:04:41.000Z</updated>
    <content type="html"><![CDATA[<p>本来只是想复习下 CSS3 动画属性, 但是一上手,就控制不住恶搞的欲望,真是可恶啊!!</p>
<p>预览地址: <a href="http://sandbox.runjs.cn/show/ih3bfqcc" target="_blank" rel="external">RPG Book</a></p>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/rpg2.png" alt="RPG Book预览图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来只是想复习下 CSS3 动画属性, 但是一上手,就控制不住恶搞的欲望,真是可恶啊!!</p>
<p>预览地址: <a href="http://sandbox.runjs.cn/show/ih3bfqcc" target="_blank" rel="external">]]>
    </summary>
    
      <category term="CSS3动画" scheme="http://imhzq.com/tags/CSS3%E5%8A%A8%E7%94%BB/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[String的正则方法和RegExp的正则方法]]></title>
    <link href="http://imhzq.com/2015/12/14/20151214_js-regex/"/>
    <id>http://imhzq.com/2015/12/14/20151214_js-regex/</id>
    <published>2015-12-13T16:00:00.000Z</published>
    <updated>2016-02-21T10:41:01.000Z</updated>
    <content type="html"><![CDATA[<p>JS 关于正则这块的函数在String和RegExp对象上都有一些方法,很容易弄混,网上的文章又介绍的特别乱,于是在这里做下总结.</p>
<h1 id="String__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5"><a href="#String__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5" class="headerlink" title="String 对象上有关正则的方法"></a>String 对象上有关正则的方法</h1><h2 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search"></a>String.prototype.search</h2><p>search 方法接受一个正则表达式作为参数,如果传入一个非正则表达式对象,则会使用 new RegExp(obj) 隐式的将其转化为正则表达式对象.</p>
<p>search 方法会返回正则表达式在字符串中首次匹配的索引,如果没有找到,则返回 -1. 如下面的例子:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phone = <span class="string">"18614086288"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = phone.search(/^<span class="number">1</span>\d[<span class="number">10</span>]$/);</span><br><span class="line">console.log(<span class="literal">result</span>);	//<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法类似于 String.prototype.indexOf,一般用来查找某个字符串是否存在某个模式.</p>
<h2 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace"></a>String.prototype.replace</h2><p>replace 这个方法主要用来替换字符串中的一些字串,接收两个参数</p>
<ol>
<li>一个将要被替换的字符串和一个替换掉第一个字符串的字符串</li>
<li>一个正则对象,这个正则匹配的对象将会被第二个参数替换</li>
</ol>
<p>这里第一个大家肯定没有问题,我们来详细讲下第二组参数:</p>
<h3 id="u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u5B57_u7B26_u4E32"><a href="#u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u5B57_u7B26_u4E32" class="headerlink" title="第一个参数是正则对象,第二个参数是字符串"></a>第一个参数是正则对象,第二个参数是字符串</h3><p>这种情况下,正则的匹配项将会被被第二个字符串替换,值得注意的地方是,这个字符串中可以包含一些特殊的变量名</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th style="text-align:left">代表的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$</td>
<td style="text-align:left">转义$,也就是插入一个”$”</td>
</tr>
<tr>
<td>$&amp;</td>
<td style="text-align:left">插入匹配的整个字串</td>
</tr>
<tr>
<td>&amp;`</td>
<td style="text-align:left">插入当前匹配子串左边的内容</td>
</tr>
<tr>
<td>&amp;’</td>
<td style="text-align:left">插入当前匹配子串右边的内容</td>
</tr>
<tr>
<td>$n</td>
<td style="text-align:left">n是个十进制数,表示插入匹配到的第 n 组</td>
</tr>
</tbody>
</table>
<p>举个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"你的名字叫ABC还是DEF"</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.replace(<span class="regexp">/([A-Za-z]+)/g</span>, <span class="string">"( $1 )"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">//output: 你的名字叫( ABC )还是( DEF )</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u51FD_u6570"><a href="#u7B2C_u4E00_u4E2A_u53C2_u6570_u662F_u6B63_u5219_u5BF9_u8C61_2C_u7B2C_u4E8C_u4E2A_u53C2_u6570_u662F_u51FD_u6570" class="headerlink" title="第一个参数是正则对象,第二个参数是函数"></a>第一个参数是正则对象,第二个参数是函数</h3><p>这种情况,是将正则表达式匹配到的子串替换成第二个函数的返回值,这个函数可以接受多个参数</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th style="text-align:left">代表的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>match</td>
<td style="text-align:left">匹配到的子串</td>
</tr>
<tr>
<td>$1,$2,…,$n</td>
<td style="text-align:left">表示匹配到的任意多分组的值[倒数第二个参数]</td>
</tr>
<tr>
<td>index</td>
<td style="text-align:left">表示匹配到的子串,在原字符串中的位置[倒数第一个参数]</td>
</tr>
<tr>
<td>input</td>
<td style="text-align:left">原字符串</td>
</tr>
</tbody>
</table>
<p>再来个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> result = property.replace(<span class="regexp">/-(.)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, $1, index,input</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">//output: vDataModel</span></span><br></pre></td></tr></table></figure></p>
<h2 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match"></a>String.prototype.match</h2><p>这个方法接受一个正则对象做参数,但是有两种情况:</p>
<ol>
<li><p>如果这个正则对象是全局匹配,则返回一个匹配到子项的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> result = property.match(<span class="regexp">/-(.)/g</span>);   <span class="comment">//这里是全局匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">//output: ["-d", "-m"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果这个正则对象不是全局匹配,那么它会返回一个结果数组,这个数组的第一项是匹配到的子串,数组的第二项到第n-2项都是匹配的分组,n-1项是匹配到的子串所在原字符串的索引位置,第n项就是原字符串,其实就是和上面介绍的replace方法第二个参数是函数时候的参数一样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> result = property.match(<span class="regexp">/-(.)/</span>);    <span class="comment">//这里不是全局匹配了</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	</span><br><span class="line"><span class="comment">//output: ["-d", "d", index: 1, input: "v-data-model"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意,这里 match 不论匹配几次都会返回第一个匹配项,并不像 RegExp.exec()一样,第二次执行就会匹配到第二个匹配项!</p>
<h1 id="RegExp__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5"><a href="#RegExp__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65B9_u6CD5" class="headerlink" title="RegExp 对象上有关正则的方法"></a>RegExp 对象上有关正则的方法</h1><h2 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test"></a>RegExp.prototype.test</h2><p>这个方法就比较简单了,test接收一个待匹配项字符串作为参数,如果匹配成功就返回 true,否则返回 false, 比较简单就不多做说明</p>
<h2 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec"></a>RegExp.prototype.exec</h2><p>这个方法要和 String.prototype.match 分清, exec 接收一个待匹配的字符串, 会返回一个和 String.prototype.match 不带全局查找时一样的返回值,需要注意的是,当这个正则表达式使用 “g” 标志做全局查找时,可以执行多次方法来查找同一个字符串中的匹配项,没有找到时返回 null ,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="string">"v-data-model"</span>;</span><br><span class="line"><span class="keyword">var</span> patter = <span class="regexp">/-(.)/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = patter.exec(property);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//output: ["-d", "d", index: 1, input: "v-data-model"]</span></span><br><span class="line"><span class="keyword">var</span> result = patter.exec(property);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//output: ["-m", "m", index: 6, input: "v-data-model"]</span></span><br><span class="line"><span class="keyword">var</span> result = patter.exec(property);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//output: null</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>JS 关于正则这块的函数在String和RegExp对象上都有一些方法,很容易弄混,网上的文章又介绍的特别乱,于是在这里做下总结.</p>
<h1 id="String__u5BF9_u8C61_u4E0A_u6709_u5173_u6B63_u5219_u7684_u65]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[文本溢出显示]]></title>
    <link href="http://imhzq.com/2015/12/13/20151213_css_warp/"/>
    <id>http://imhzq.com/2015/12/13/20151213_css_warp/</id>
    <published>2015-12-12T16:00:00.000Z</published>
    <updated>2015-12-20T16:04:32.000Z</updated>
    <content type="html"><![CDATA[<p>我们写页面的时候经常会遇到，文字超出容器的宽度的情况，通常情况下会对文本进行裁剪，并加上三个点，CSS3 中新增了一个 text-overflow 属性，可以更改文本溢出时的样式，我们这次就来说说这个东西。</p>
<p>上面那个问题可以用这段代码解决：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">text-overflow</span>:<span class="value"> ellipsis</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">white-space</span>:<span class="value"> nowrap</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在我们来看看这段 CSS，text-overflow 有两个个属性: 一个是 <code>clip</code>，这个属性是 text-overflow 的默认属性，表示如果文本溢出则裁剪不做任何操作，另一个是 <code>ellipsis</code> 表示文本溢出时用…代替。ok，这样看似好像可以解决我们的问题了，native，这个text-overflow 只能针对一行文本，多行就没有效果了，那我的文本超过一行会自动换行啊，怎么办？于是我们引入<code>white-space</code> 这个属性，这个属性值比较多，咱们先来看看效果：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/21ojzak1/embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe>
<p><br></p>
<p>用白话文来说就是：</p>
<p><code>normal</code> : <code>合并</code>空格、换行符、制表符为一个空格，文本会<code>自动</code>换行</p>
<p><code>nowrap</code> : <code>合并</code>空格、换行符、制表符为一个空格，文本<code>不会</code>自动换行</p>
<p><code>pre</code>: <code>保留</code>空格、换行符、制表符，文本<code>不会</code>自动换行</p>
<p><code>pre-wrap</code> : <code>保留</code>空格、换行符、制表符，文本<code>会</code>自动换行</p>
<p><code>pre-line</code> : <code>合并</code>空格、制表符为一个空格，<code>保留</code>换行符，文本<code>会</code>自动换行</p>
<p>根绝我们的需求，我们依然需要合并换行符、空格、制表符，但是不要自动换行，所以我们选择 <code>nowrap</code>，最后使用 <code>overflow:hidden;</code> 来隐藏溢出的部分。</p>
<p>有的朋友又会问，那多行溢出是不是就不能用css解决了？当然可以，css无所不能！来 show code：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/5rkz77ek/embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe>
<p>其中的秘诀就在于，盒子内容区的高一定要等于文本的行高，比如这里，我们需要保留 5 行文本，就设置 <code>height:5em;</code> 也可以换算成具体的像素值，最后在盒子右下绝对定位一个 <code>...</code> 元素，盖住最后的文本就结束了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们写页面的时候经常会遇到，文字超出容器的宽度的情况，通常情况下会对文本进行裁剪，并加上三个点，CSS3 中新增了一个 text-overflow 属性，可以更改文本溢出时的样式，我们这次就来说说这个东西。</p>
<p>上面那个问题可以用这段代码解决：</p>
<figu]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IE6/7中的inline-block]]></title>
    <link href="http://imhzq.com/2015/12/12/20151212_css_ie67_inline-block/"/>
    <id>http://imhzq.com/2015/12/12/20151212_css_ie67_inline-block/</id>
    <published>2015-12-11T16:00:00.000Z</published>
    <updated>2015-12-18T15:58:11.000Z</updated>
    <content type="html"><![CDATA[<p>display:inline-block;在ie6、ie7下只有设置在默认显示方式为inline的元素上才会生效。为什么哪？</p>
<p>历史原因，早起的IE浏览器在渲染引擎中，如果所有的元素都应用布局的话，IE的性能会受到很大影响，当时IE团队采用了 layout ，只将布局应用在需要的元素上，通过这种办法来减少布局的性能开销， layout 也就是现在常说的 hasLayout，IE8之后更换了引擎，所以这个问题只会出现在 IE6/7中（5.5 不在考虑范围）。</p>
<p>IE6/7中并不是没有 inline-block，早在IE5.5 中就已经支持了，只是它的 inline-block 比较个性，在 IE6/7 中 display:inline-block 是可以触发 hasLayout 的，触发了 hasLayout 的元素表现出来的特征就是一个独立的矩形容器，可以设置宽高而且不受外部元素的影响，类似于现代浏览器中的 BFC。</p>
<p>在IE6/7中，如果是 inline 元素，只要触发了 hasLayout 的元素都会表现的像 inline-block，所以下面这两种写法都可以实现效果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">span</span><span class="rules">&#123;<span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;&#125;</span> </span><br><span class="line"><span class="tag">span</span><span class="rules">&#123;<span class="rule"><span class="attribute">zoom</span>:<span class="value"><span class="number">1</span></span></span>;&#125;</span> </span><br><span class="line"><span class="comment">/* inline-block 和 zoom 都会触发 haslayout，拥有独立布局，可以设置宽高，此外元素本身是 inline 元素，结果就是表现的和 inline－block 一样 */</span></span><br></pre></td></tr></table></figure></p>
<p>如果是 block 元素，比如div 这类标签:</p>
<p>方案1：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="comment">/* 触发hasLayout，拥有自身布局，然并卵，你依然不是 inline 元素，该独占一行还是独占一行 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>方案2：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;   <span class="comment">/* 触发hasLayout，拥有自身布局，可以设置宽高 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>; <span class="comment">/* 强制改成 inline 元素 */</span></span><br><span class="line">    <span class="comment">/* 此时表现就和 inline－block 一样了 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>方案3:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">zoom</span>:<span class="value"> <span class="number">1</span></span></span>;   <span class="comment">/* 换做 zoom 来触发 hasLayout 效果也一样，拥有自身布局，可以设置宽高 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>; <span class="comment">/* 强制改成 inline 元素 */</span></span><br><span class="line">    <span class="comment">/* 此时表现就和 inline－block 一样了 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>方案4: 加个 IE6/7 hank做兼容<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block; <span class="comment">/* 兼容 IE6/7 的 inline 元素和 现代浏览器*/</span></span><br><span class="line">    *<span class="attribute">display</span>: inline; <span class="comment">/* IE6/7 的block 元素 */</span></span><br><span class="line">    *<span class="attribute">zoom</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就解决了IE6/7中 block元素 inline-block 依旧换行的问题。虽然现在基本上已经不用再兼容 IE6/7 了，但是挖一挖以前的故事还是挺有趣的 :-)</p>
<p>​</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>display:inline-block;在ie6、ie7下只有设置在默认显示方式为inline的元素上才会生效。为什么哪？</p>
<p>历史原因，早起的IE浏览器在渲染引擎中，如果所有的元素都应用布局的话，IE的性能会受到很大影响，当时IE团队采用了 layout ，只]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS反柯里化]]></title>
    <link href="http://imhzq.com/2015/12/11/20151211_js-uncurrying/"/>
    <id>http://imhzq.com/2015/12/11/20151211_js-uncurrying/</id>
    <published>2015-12-10T16:00:00.000Z</published>
    <updated>2015-12-15T16:12:55.000Z</updated>
    <content type="html"><![CDATA[<p>之前讲过<a href="http://imhzq.com/2015/12/10/20151210_js-currying/">柯里化</a>，那反柯里化又是啥？顾名思义，反柯里化就是和柯里化反着来，柯里化是分布计算函数，目的是为了缩小适用范围，创建出一个更剧针对性的函数，而反柯里化则恰恰相反，是为了扩大适用范围，创建一个适用范围更广的函数，使本来只有特定对象才能使用的方法，扩展到更多对象，嗯，听起来和call和apply的功能好像一样了,不过反柯里化连 this 都给提取出来了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">uncurrying</span> = <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">apply</span><span class="params">(self, arguments)</span></span>; <span class="comment">//借用call</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> push  = <span class="keyword">Array</span>.prototype.push.uncurrying();</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">push(<span class="keyword">list</span>, <span class="number">4</span>);</span><br><span class="line">console.log(<span class="keyword">list</span>);	<span class="comment">//[ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>
<p>这里我们通过 uncurrying 函数，将 Array.prototype.push.call 变成了一个通用的push函数，这样以来 push 函数的功能就和 Array.prototype.push.call 一样了，同样不仅仅能操作Array 对象，其他对象也可以。</p>
<p>更令人惊讶的是， Function.prototype.call 和 Function.prototype.apply 也能被 uncurrying：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">uncurrying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">var</span> apply = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">apply</span>.<span class="title">uncurrying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">call(fn, &#123;name: <span class="string">'赵日天'</span>&#125;,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);        <span class="comment">//赵日天 &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125;</span></span><br><span class="line">apply(fn, &#123;name: <span class="string">'李杀神'</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">//李杀神  &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">apply([].push, <span class="keyword">list</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">console.log(<span class="keyword">list</span>);	<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<p>是不是很炫酷？然而并没有什么卵用，只是使得对函数的调用更像 js 的前身 Scheme 了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前讲过<a href="http://imhzq.com/2015/12/10/20151210_js-currying/">柯里化</a>，那反柯里化又是啥？顾名思义，反柯里化就是和柯里化反着来，柯里化是分布计算函数，目的是为了缩小适用范围，创建出一个更剧针对性的函数，]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS柯里化]]></title>
    <link href="http://imhzq.com/2015/12/10/20151210_js-currying/"/>
    <id>http://imhzq.com/2015/12/10/20151210_js-currying/</id>
    <published>2015-12-09T16:00:00.000Z</published>
    <updated>2015-12-15T16:27:50.000Z</updated>
    <content type="html"><![CDATA[<p>柯里化（英语：Currying），是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。白话文就是：一个currying函数首先接受一些参数，接受了这些参数后，函数不会立即求值，而是继续返回一个新的函数，刚才传入的参数以闭包的方式保存起来，待到真正需要求值的时候，之前传入的所有参数再一起用以求值。talk is cheap，show me the code：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = <span class="built_in">arguments</span>.length; i&lt;len;i++)&#123;</span><br><span class="line">			sum+= <span class="built_in">arguments</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">1</span>));		<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">4</span>));		<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>这个函数是个简单的求和函数,每次加入数字，都会做一次求和，但是我们其实并不关心这些，我们只关心最后一次的求和，ok，那我们把这些参数保存起来，然后检查argument的长度，当是0的时候，再一起求和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [];</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> num1 + num2;</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			[].push.apply(args, <span class="built_in">arguments</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">fn1(<span class="number">1</span>);</span><br><span class="line">fn1(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">fn1(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fn1()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>ok，这次我们最后一次才求和，但是这样看起来还是好难受，fn1函数一次又一次的调用，视觉还是体力上都不太好,我们稍稍修改一下上面的函数，让他返回匿名函数本身，方便链式操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [];</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> num1 + num2;</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			[].push.apply(args, <span class="built_in">arguments</span>);</span><br><span class="line">			<span class="keyword">return</span> _fn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">fn1(<span class="number">1</span>)(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">4</span>)(); <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数其实就已经是一个柯里化的例子了，现在再回头看看定义～是不是很简单？最后，我们再将上面这个函数重构一下，提出一个公共的 currying 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [];  <span class="comment">//保存参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123; </span><br><span class="line">			<span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args); <span class="comment">//调用fn</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			[].push.apply(args, <span class="built_in">arguments</span>); <span class="comment">//将新的参数 push到args 数组中保存</span></span><br><span class="line">			<span class="keyword">return</span> _fn; <span class="comment">//返回函数本身，方便链式操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curryFn = currying(fn);</span><br><span class="line">curryFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了一个 currying 函数的编写。</p>
<h2 id="u603B_u7ED3_u67EF_u91CC_u5316_u7684_u4F5C_u7528"><a href="#u603B_u7ED3_u67EF_u91CC_u5316_u7684_u4F5C_u7528" class="headerlink" title="总结柯里化的作用"></a>总结柯里化的作用</h2><ol>
<li>延迟计算，这个上面的栗子已经很好的证明了</li>
<li>参数复用，多次调用同一个参数，并且传递的参数基本上相同，那么来试试柯里化吧</li>
<li>动态创建函数，部分计算后，返回一个新的函数，这样就避免了重复计算。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>柯里化（英语：Currying），是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。白话文就是：一个currying函数首先接受一些参数，接受了这些参数后，函数不会立即求值，而是继续返回一个新的函数，刚才传入的参数以闭包的]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS实现简单的AOP]]></title>
    <link href="http://imhzq.com/2015/12/09/20151209_js-aop/"/>
    <id>http://imhzq.com/2015/12/09/20151209_js-aop/</id>
    <published>2015-12-08T16:00:00.000Z</published>
    <updated>2015-12-15T11:09:57.000Z</updated>
    <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）指的是面向切面编程，比如说ASP.NET的Http管道等，主要作用就是把一些跟核心业务逻辑无关的功能抽出来，比如说日志记录，验证，计时，过滤器，异常处理等这些边边角角的东西，然后在动态的加入业务逻辑模块中，这样可以保证业务模块的纯净和高内聚，而且可以很方便的重用这些模块。</p>
<p>在 C# 中得用反射或者DynamicProxy来实现,JS这类函数式语言实现起来极其简单,如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;	<span class="comment">//保存函数本体</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//返回一个新的函数体，包含函数本体和新增函数</span></span><br><span class="line">		fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); 	<span class="comment">//修正 this 调用新增函数</span></span><br><span class="line">		<span class="keyword">return</span> self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); 	<span class="comment">//修正this， 调用函数本体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> result = self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">		fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"主业务"</span>);</span><br><span class="line">&#125;.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"主业务之前执行"</span>)</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"主业务之后执行"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn();	<span class="comment">//主业务之前执行    主业务     主业务之后执行</span></span><br></pre></td></tr></table></figure>
<p>这里只是个简单的demo，使用时根据具体的业务逻辑适当修改。怎么样，是不是很简单，是不是尝到了函数式语言的甜头了 :-)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>AOP（Aspect Oriented Programming）指的是面向切面编程，比如说ASP.NET的Http管道等，主要作用就是把一些跟核心业务逻辑无关的功能抽出来，比如说日志记录，验证，计时，过滤器，异常处理等这些边边角角的东西，然后在动态的加入业务逻辑模块中，这样]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闭包的应用]]></title>
    <link href="http://imhzq.com/2015/12/08/20151208_js-closure-apply/"/>
    <id>http://imhzq.com/2015/12/08/20151208_js-closure-apply/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-15T08:00:05.000Z</updated>
    <content type="html"><![CDATA[<p>说到闭包就先要了解两个小知识。第一个就是作用域，javascript 的每个函数都有自己的作用域，函数除了可以访问自身作用域的活动对象外，还可以访问外层作用域的活动对象,但外部作用域不能访问内部函数作用域。如果在函数中搜索一个变量没有找到，那么此次搜索会随着代码执行环境，逐层向外部作用域搜索，一直搜索到全局对象为止。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(b);  	<span class="comment">//2</span></span><br><span class="line">		<span class="built_in">console</span>.log(a);		<span class="comment">//1</span></span><br><span class="line">	&#125;</span><br><span class="line">	fun2();</span><br><span class="line">	<span class="built_in">console</span>.log(c)			<span class="comment">//ReferenceError: c is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>
<p>第二个是变量的生命周期，函数内部的活动对象，会随着函数的退出而销毁，但是考虑下面的代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var <span class="function"><span class="keyword">fun</span> = <span class="title">function</span></span>()&#123;</span><br><span class="line">	var i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> function()&#123;</span><br><span class="line">		i++;</span><br><span class="line">		console.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = <span class="function"><span class="keyword">fun</span>();</span><br><span class="line"><span class="title">f</span></span>(); <span class="regexp">//</span><span class="number">2</span></span><br><span class="line">f(); <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">f(); <span class="regexp">//</span><span class="number">4</span></span><br><span class="line">f(); <span class="regexp">//</span><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这里，fun执行完毕后，其中的变量 i 并没有被销毁，因为返回的匿名函数还以引用着 fun 的活动对象，换句话说，fun 执行完毕后，会销毁其执行环境的作用域链，但它的活动对象仍然保留在内存中，直到匿名函数被销毁后，fun 的活动对象才会被销毁。一图抵万言：</p>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/closure.001.jpeg" alt="函数fun执行环境的作用域链和闭包"></p>
<h1 id="u95ED_u5305_u5E94_u7528"><a href="#u95ED_u5305_u5E94_u7528" class="headerlink" title="闭包应用"></a>闭包应用</h1><p>上面两个知识明白后，我们正式切入正题，讲一讲闭包的应用。</p>
<p>先来一个经典的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>3<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>4<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"test"</span>&gt;</span>5<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">".test"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++)&#123;</span><br><span class="line">		nodes[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试这段代码，你会发现每次输出的都是 <code>5</code>。 因为当点击事件结束的时候， for循环已经跑完了，i 此时的值是 5，所以，在onclick事件函数中顺着作用域链从内到外查找变量 i 时，查到的值总是 5。</p>
<p>这个问题可以通过闭包解决，把每次循环的 i 都封闭起来。那么在事件触发由内向外查询 i 的时候，就会先查找到封闭在闭包中的 i，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">".test"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        nodes[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的道理，咱们还能写出这样判断类型的函数：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">Type</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> typeArry = [<span class="string">"String"</span>,<span class="string">"Array"</span>,<span class="string">"Number"</span>,<span class="string">"Function"</span>,<span class="string">"Undefined"</span>,<span class="string">"Object"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = 0, len = typeArry.length; i &lt; len; i++ )&#123;</span><br><span class="line">	(function(i)&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">type</span> =  typeArry[i];</span><br><span class="line">		<span class="keyword">Type</span>[<span class="string">"is"</span> + <span class="keyword">type</span>] = function(obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> Object.prototype.<span class="keyword">toString</span>.call(obj) === <span class="string">"[object "</span>+ <span class="keyword">type</span> +<span class="string">"]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">Type</span>.isArray([])); <span class="comment">//true</span></span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">Type</span>.isString(<span class="string">""</span>)); <span class="comment">//true</span></span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">Type</span>.isString(1)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u5C01_u88C5_u53D8_u91CF"><a href="#u5C01_u88C5_u53D8_u91CF" class="headerlink" title="封装变量"></a>封装变量</h2><p>闭包可以把一些不需要暴露在全局的变量封装成“私有变量”。比如在蝴蝶书中的一个例子，记忆函数，假如我们要写一个计算阶乘的函数，如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="function"><span class="keyword">fun</span>  = <span class="title">function</span></span>(n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n * arguments.callee(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>(5));</span><br><span class="line"><span class="title">console</span></span>.log(<span class="function"><span class="keyword">fun</span>(4));</span><br><span class="line"><span class="title">console</span></span>.log(<span class="function"><span class="keyword">fun</span>(3));</span></span><br></pre></td></tr></table></figure>
<p>这个函数可以正常工作，但是在 fun(5) 中我们已经计算过了 4 和 3 的值了，但是在执行 fun4 和 fun3时又重复计算了，这严重影响了性能，我们可以让该函数记住计算后的值，这样就可以减少计算量了，如下：<br> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1 = (function()&#123;</span><br><span class="line">	<span class="keyword">var</span> memo = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">var</span> recur = function(n)&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="literal">result</span> = memo[n];</span><br><span class="line">		<span class="keyword">if</span>(typeof <span class="literal">result</span> !== <span class="string">"number"</span>)&#123;</span><br><span class="line">			<span class="literal">result</span> = n * recur(n - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> memo[n] = <span class="literal">result</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(fun1(<span class="number">5</span>));</span><br><span class="line">console.log(fun1(<span class="number">4</span>));</span><br><span class="line">console.log(fun1(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<p>我们将 memo 对象封装在了闭包中，无法在外部访问 memo 对象，避免了这个变量在其他地方被不小心修改而引发错误。最后我们来对这段代码进行重构，提出一个通用的记忆函数：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memoizer  = function(memo, func)&#123;</span><br><span class="line">	<span class="keyword">var</span> recur = function(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &amp;&amp; !memo.hasOwnProperty(n))&#123;</span><br><span class="line">			<span class="keyword">var</span> <span class="literal">result</span> = func(n);</span><br><span class="line">			<span class="keyword">return</span> memo[n] = <span class="literal">result</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> meno[n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> memo = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> fun2 = memoizer(memo, fun);</span><br><span class="line">console.log(fun2(<span class="number">5</span>));</span><br><span class="line">console.log(fun2(<span class="number">4</span>));</span><br><span class="line">console.log(fun2(<span class="number">3</span>));</span><br><span class="line">console.log(memo);	//&#123; '<span class="number">0</span>': <span class="number">0</span>, '<span class="number">1</span>': <span class="number">1</span>, '<span class="number">3</span>': <span class="number">6</span>, '<span class="number">4</span>': <span class="number">24</span>, '<span class="number">5</span>': <span class="number">120</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u6A21_u62DF_u9762_u5411_u5BF9_u8C61"><a href="#u6A21_u62DF_u9762_u5411_u5BF9_u8C61" class="headerlink" title="模拟面向对象"></a>模拟面向对象</h2><p>对象以方法的形式保留了过程，而闭包则是在过程中以环境的形式保存了数据，通常面向对象的能实现的功能，用闭包也能实现，比如下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Extent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value++;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Extent();</span><br><span class="line">obj.say() 	<span class="comment">//1</span></span><br><span class="line">obj.say()	<span class="comment">//2</span></span><br><span class="line">obj.say()	<span class="comment">//3</span></span><br><span class="line">obj.say()	<span class="comment">//4</span></span><br></pre></td></tr></table></figure></p>
<p>上面是面向对象的写法，下面来看看闭包的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			value++;</span><br><span class="line">			<span class="built_in">console</span>.log(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> extent = extent();</span><br><span class="line">extent.say()	<span class="comment">//1</span></span><br><span class="line">extent.say()	<span class="comment">//2</span></span><br><span class="line">extent.say()	<span class="comment">//3</span></span><br><span class="line">extent.say()	<span class="comment">//4</span></span><br></pre></td></tr></table></figure></p>
<p>闭包是函数式编程中的一个重要概念，很多设计模式都可以用闭包来实现，也是js学习中的重中之重，更多应用大家自己去发掘吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说到闭包就先要了解两个小知识。第一个就是作用域，javascript 的每个函数都有自己的作用域，函数除了可以访问自身作用域的活动对象外，还可以访问外层作用域的活动对象,但外部作用域不能访问内部函数作用域。如果在函数中搜索一个变量没有找到，那么此次搜索会随着代码执行环境，逐]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片格式]]></title>
    <link href="http://imhzq.com/2015/12/07/20151207_image-type/"/>
    <id>http://imhzq.com/2015/12/07/20151207_image-type/</id>
    <published>2015-12-06T16:00:00.000Z</published>
    <updated>2015-12-19T14:33:56.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个前端，每天与各种各样的图片打交道，那么它们有什么区别？应用场景分别是什么？欢迎收看本期今日xx :-)</p>
<p>我们常见的图片格式有，gif,png,jpeg,ico这几种，哦对，还有google的 <a href="https://zh.wikipedia.org/wiki/WebP" target="_blank" rel="external">WebP</a>。使用图片也要遵照基本法的，咱们先讲图片法。不同格式图像都有着自己的特点，这些特点决定了我们何时何地如何去使用它们。</p>
<h1 id="u56FE_u5F62"><a href="#u56FE_u5F62" class="headerlink" title="图形"></a>图形</h1><p>网站的 logo、图标、草图等都属于图形，这些图像通常由连续的线条或其他尖锐的颜色过渡组成，颜色数量相对较少</p>
<h1 id="u7167_u7247"><a href="#u7167_u7247" class="headerlink" title="照片"></a>照片</h1><p>照片通常包含比较丰富的颜色，并且包含平滑的颜色过渡和渐变。</p>
<p>就图像格式而言，GIF通常用来显示图形，而jpeg更适合显示照片，png两者都合适。</p>
<h1 id="u50CF_u7D20_u548CRGB"><a href="#u50CF_u7D20_u548CRGB" class="headerlink" title="像素和RGB"></a>像素和RGB</h1><p>图像由像素组成，像素是图像最小的信息单元。有多种颜色模型可以来描述像素，比如 RGB、RGBa等。</p>
<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>RGB颜色模型，采用包含红(R)、绿(G)、蓝(B)的数量多少的方式来描述一个像素。R、G、B被称作通道，每种通道的强度范围在 0~255 之间。我们在CSS和HTML中实用的十六禁止的通道值，范围从 00~FF，将强度不同的成分合在一起就组成了不同的颜色。</p>
<h2 id="RGBa"><a href="#RGBa" class="headerlink" title="RGBa"></a>RGBa</h2><p>RGBa 并非一种截然不同的颜色模型，而是在 RGB 的基础上做了扩展。额外的成分 a 代表 alpha（可变的） 透明，值的范围也是0~255，不同的程序和库会以不同的方式展示比如0～100%。</p>
<h2 id="u771F_u8272_u5F69_u56FE_u50CF_u548C_u8C03_u8272_u677F_u56FE_u50CF_u683C_u5F0F"><a href="#u771F_u8272_u5F69_u56FE_u50CF_u548C_u8C03_u8272_u677F_u56FE_u50CF_u683C_u5F0F" class="headerlink" title="真色彩图像和调色板图像格式"></a>真色彩图像和调色板图像格式</h2><p>使用RGB颜色模型究竟可以展现 256x256x256＝16777216 种颜色。可以支持这么多种颜色的图片格式叫真色彩图像格式，比如jpeg和png的真色彩类型。</p>
<p>为了在存储图像信息时节省一些空间，有种技术可以将图像中各种不同的颜色提取出来建立一个表，这个表叫做调色板（也叫索引）。有了这个颜色表，就可以通过将调色板中的条目和每个像素重新匹配。达到重绘整个图像的目的。</p>
<p>gif和png8会限制调色板做多只能包含 256 种颜色，这不是说只可以从 256 中定义好的颜色中选择，而是你可以从 1600w＋的颜色中选择你需要的颜色，但是一个图片只能包含 256 种颜色。</p>
<h2 id="u9694_u884C_u626B_u63CF"><a href="#u9694_u884C_u626B_u63CF" class="headerlink" title="隔行扫描"></a>隔行扫描</h2><p>当网速比较慢的时候，大图会随着下载进度逐行显示。为了提高用户体验，部分图像格式支持对那些连续采样的图像进行隔行扫描。隔行扫描(又被称作渐进式图片)可以让用户在图片下载完成前，看到一个模糊的版本，从而在用户心理上消除页面加载缓慢的感觉。具体可以参考张鑫旭大大的这篇博文 <a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片及其相关</a></p>
<h1 id="u4E0D_u540C_u683C_u5F0F_u56FE_u50CF_u7684_u7279_u6027"><a href="#u4E0D_u540C_u683C_u5F0F_u56FE_u50CF_u7684_u7279_u6027" class="headerlink" title="不同格式图像的特性"></a>不同格式图像的特性</h1><p>看完上面的资料后，咱们来看看gif、jpeg和 png 这 3种格式的区别。</p>
<h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><hr>
<p>gif是一种调色板图片格式，只能包含256种颜色。</p>
<h3 id="u900F_u660E"><a href="#u900F_u660E" class="headerlink" title="透明"></a>透明</h3><p>gif 允许一个二进制类型的透明，要没每个像素要么是完全透明要么就是完全不透明。透明也会占用一个调色板条目，也就只剩下255种颜色可选了。</p>
<h3 id="u52A8_u753B"><a href="#u52A8_u753B" class="headerlink" title="动画"></a>动画</h3><p>gif 格式支持动画。</p>
<h3 id="u65E0_u635F"><a href="#u65E0_u635F" class="headerlink" title="无损"></a>无损</h3><p>gif也是无损的，也就是说你可以打开任意一个 gif 文件，做一些修改，保存关闭时不会损失任何质量。</p>
<h3 id="u9010_u884C_u626B_u63CF"><a href="#u9010_u884C_u626B_u63CF" class="headerlink" title="逐行扫描"></a>逐行扫描</h3><p>生成GIF会使用一个LZW压缩算法来减小文件大小，当压缩gif时，会从上到下一行一行的对像素进行扫描。这种情况下，当图片在水平方向有很多重复颜色时，可以获得更好的压缩效果。</p>
<h3 id="u9694_u884C_u626B_u63CF-1"><a href="#u9694_u884C_u626B_u63CF-1" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>gif支持可选的隔行扫描，由于gif有256色的限制，所以不适合显示照片。gif更适合显示图形，但是png8才是显示图形最佳格式。所以，只有当使用动画时才应该使用 gif。</p>
<h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><hr>
<p>jpeg是一种有损压缩格式，用户可以设置自定义质量级别，这个级别决定了有多少信息会被丢弃。质量级别从0～100，但是就算设置为100，也同样会有一定程度的质量损耗。</p>
<p>当你要对图片进行多项编辑操作室，最好使用无损的图像格式来保存中间结果，然后在完成所有操作后，另存为jpeg格式，否则，你将会在每次保存都丢失一些质量。</p>
<p>有些操作是无损的：</p>
<ol>
<li>旋转（只有在旋转90度、180度、270度的情况下）</li>
<li>裁剪</li>
<li>翻转 (水平或垂直)</li>
<li>从标准模式切换至渐进模式，反之亦然</li>
<li>编辑图像的元数据（在优化jpeg图像时极为重要）</li>
</ol>
<h3 id="u900F_u660E_u548C_u52A8_u753B"><a href="#u900F_u660E_u548C_u52A8_u753B" class="headerlink" title="透明和动画"></a>透明和动画</h3><p>jpeg不支持透明和动画</p>
<h3 id="u9694_u884C_u626B_u63CF-2"><a href="#u9694_u884C_u626B_u63CF-2" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>渐进式jpeg<a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片及其相关</a></p>
<h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><hr>
<p>为了弥补gif格式的缺点，并规避 LZW 算法的专利问题，PNG应运而生。</p>
<h3 id="PNG8"><a href="#PNG8" class="headerlink" title="PNG8"></a>PNG8</h3><p>调色板PNG的别称</p>
<h3 id="PNG24"><a href="#PNG24" class="headerlink" title="PNG24"></a>PNG24</h3><p>真色彩PNG的别称，但是不包括 alpha 通道</p>
<h3 id="PNG32"><a href="#PNG32" class="headerlink" title="PNG32"></a>PNG32</h3><p>真色彩PNG的别称，包括 alpha 通道</p>
<h3 id="u900F_u660E-1"><a href="#u900F_u660E-1" class="headerlink" title="透明"></a>透明</h3><p>PNG支持完全的 alpha 透明，IE6中会出现问题</p>
<h3 id="u52A8_u753B-1"><a href="#u52A8_u753B-1" class="headerlink" title="动画"></a>动画</h3><p>有相关实验的实际应用，但还没有跨浏览器的解决方案</p>
<h3 id="u65E0_u635F-1"><a href="#u65E0_u635F-1" class="headerlink" title="无损"></a>无损</h3><p>与jpeg不，png是一种无损的图像格式：多次编辑不会降低其质量，这使得用真色彩png来保存jpeg的修改过程的中间产物非常合适。</p>
<h3 id="u9010_u884C_u626B_u63CF-1"><a href="#u9010_u884C_u626B_u63CF-1" class="headerlink" title="逐行扫描"></a>逐行扫描</h3><p>和gif格式一样，相对于那些垂直方向有重复颜色的图像来说，png格式对那些水平方向上有重复颜色的图像压缩比更高。so，sprite水平摆放会获得更小的尺寸。</p>
<h3 id="u9694_u884C_u626B_u63CF-3"><a href="#u9694_u884C_u626B_u63CF-3" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>png支持隔行扫描，并使用了比gif更先进的算法，它允许对真实图像进行更好的“预览”，但是大小会更大些。</p>
<h3 id="u548C_GIF__u5BF9_u6BD4"><a href="#u548C_GIF__u5BF9_u6BD4" class="headerlink" title="和 GIF 对比"></a>和 GIF 对比</h3><p>除了不支持动画外，调色板png 拥有gif所有的功能。此外，它还支持 alpha 透明，并且通常压缩比更高，文件大小更小。所以 ，应该尽可能的使用 png8替代 gif。</p>
<p>有一个例外是颜色数量较少的小图片，gif的压缩率会更高些。但是这种小图一般都被放在 css sprite 中，因为 http 请求的开销已经大大超过节省那点带宽，而且用png保存sprite图像可以获得更高的压缩率。</p>
<h3 id="u548C_jpeg__u5BF9_u6BD4"><a href="#u548C_jpeg__u5BF9_u6BD4" class="headerlink" title="和 jpeg 对比"></a>和 jpeg 对比</h3><p>当图像中颜色超过 256中时，需要使用真色彩图像格式。jpeg的压缩比更高，而且一般来说，jpeg也是照片存储的实际标准。但由于 jpeg 是有损的，而且在清晰的颜色过渡周围会有大色块，因此下面情况使用PNG更合适：</p>
<ol>
<li>当图片颜色<code>略微</code>超过256，可以在不损耗人和可见质量的前提下，将图片转化为png8格式。令人惊奇的是，有时候，就算你剥离了 1000种以上的颜色，都不会注意到图片中的所发生的变化</li>
<li>当大色块变得不能接受的时候，比如包含很色颜色的图像或软件菜单的截图，这时候png更好。</li>
</ol>
<h2 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h2><hr>
<p>WebP最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。2011年11月8日，Google开始让WebP支持无损压缩和透明色的功能。但目前只有 chrome 和 opera 浏览器支持原生 WebP 格式。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><h2 id="GIF-1"><a href="#GIF-1" class="headerlink" title="GIF"></a>GIF</h2><h3 id="u4F18_u70B9_3A"><a href="#u4F18_u70B9_3A" class="headerlink" title="优点:"></a>优点:</h3><p>动画、无损</p>
<h3 id="u7F3A_u70B9_uFF1A"><a href="#u7F3A_u70B9_uFF1A" class="headerlink" title="缺点："></a>缺点：</h3><p>256色、压缩比不如 png8（颜色少的小图虽然压缩比比 png8高，但是 sprite 格式的 png 更优）、不支持透明</p>
<h2 id="JPEG-1"><a href="#JPEG-1" class="headerlink" title="JPEG"></a>JPEG</h2><h3 id="u4F18_u70B9_uFF1A"><a href="#u4F18_u70B9_uFF1A" class="headerlink" title="优点："></a>优点：</h3><p>真色彩、压缩比可调</p>
<h3 id="u7F3A_u70B9_uFF1A-1"><a href="#u7F3A_u70B9_uFF1A-1" class="headerlink" title="缺点："></a>缺点：</h3><p>有损、不支持透明和动画</p>
<h2 id="PNG8-1"><a href="#PNG8-1" class="headerlink" title="PNG8"></a>PNG8</h2><h3 id="u4F18_u70B9_uFF1A-1"><a href="#u4F18_u70B9_uFF1A-1" class="headerlink" title="优点："></a>优点：</h3><p>无损、压缩比高、支持 alpha 通道</p>
<h3 id="u7F3A_u70B9_uFF1A-2"><a href="#u7F3A_u70B9_uFF1A-2" class="headerlink" title="缺点："></a>缺点：</h3><p>256色</p>
<h2 id="PNG24/PNG32"><a href="#PNG24/PNG32" class="headerlink" title="PNG24/PNG32"></a>PNG24/PNG32</h2><h3 id="u4F18_u70B9_uFF1A-2"><a href="#u4F18_u70B9_uFF1A-2" class="headerlink" title="优点："></a>优点：</h3><p>无损、真色彩、PNG32支持 alpha 通道、PNG24不支持 alpha 通道</p>
<h3 id="u7F3A_u70B9_uFF1A-3"><a href="#u7F3A_u70B9_uFF1A-3" class="headerlink" title="缺点："></a>缺点：</h3><p>图片较大</p>
<h2 id="u5B9E_u9645_u5E94_u7528"><a href="#u5B9E_u9645_u5E94_u7528" class="headerlink" title="实际应用"></a>实际应用</h2><p>这些格式没有孰优孰略，完全看需求：<br>jpeg通常用在颜色较多、但不要求特别精细的图片上，如照片、宣传图、背景等。<br>png通常用在颜色复杂并且要求特别精细或者有透明需求的图片上，如复杂的logo、图标等。由于无损还可以当做“原图”来存档使用。<br>png8在png的基础上“减去”颜色复杂。<br>gif由于静态部分可以被png8代替，所以通常只用于简单的动画。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个前端，每天与各种各样的图片打交道，那么它们有什么区别？应用场景分别是什么？欢迎收看本期今日xx :-)</p>
<p>我们常见的图片格式有，gif,png,jpeg,ico这几种，哦对，还有google的 <a href="https://zh.wikipedia.]]>
    </summary>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[call和apply]]></title>
    <link href="http://imhzq.com/2015/12/06/20151206_js-call-apply/"/>
    <id>http://imhzq.com/2015/12/06/20151206_js-call-apply/</id>
    <published>2015-12-05T16:00:00.000Z</published>
    <updated>2015-12-14T17:32:45.000Z</updated>
    <content type="html"><![CDATA[<p>ECMAScript 3给 Function 的原型中定义了两个方法，分别是 Function.prototype.call 和 Function.prototype.apply。它们两个都可以改变函数体内 this的指向，区别仅在第二个参数不同。</p>
<p>apply 接受两个参数，第一个参数表示函数体内的 this 的指向；第二个函数表示一个参数数组，也可以是类数组，表示传递给这个函数的参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name: <span class="string">"obj1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">"obj2"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">": my numbers is "</span> + [a, b, c]);  </span><br><span class="line">&#125;</span><br><span class="line">sayNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);	<span class="comment">//window: my numbers is 1,2,3</span></span><br><span class="line">sayNumbers.call(obj1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);		<span class="comment">//obj1: my numbers is 1,2,3</span></span><br><span class="line">sayNumbers.apply(obj2, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);	<span class="comment">//obj2: my numbers is 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>因为 function 的参数就保存在一个 arguments 类数组中，所以 apply 会常用些。这里我们展示了 apply 和 call 的第一个用法：改变 this 的指向，这里我们使用 sayNumbers.call(obj1, 1, 2, 3)，函数体内的 this 就指向的是 obj1，同理 sayNumbers.apply(obj2, [1, 2, 3]) 中的 this 指向的就是 obj2。</p>
<p>大家应该知道在 ECMAScript 5 中新增了一个 Function.prototype.bind 函数，这个方法的作用和call 和 apply 很相似，就是将函数中的this 绑定到一个对象上。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name: <span class="string">"obj1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;.bind(obj1);</span><br><span class="line">sayName();      <span class="comment">// obj1</span></span><br></pre></td></tr></table></figure>
<p>大家会发现这个好像个 call 和 apply 的功能几乎一样啊！然而，如果一样也就没有 bind 存在的理由了，bind 还有第二个参数，除了第一个实参外，传入 bind 的其他实参也会绑定至相对应的实参，这被称作柯里化。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="title">function</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;.bind(null, <span class="number">1</span>);    <span class="comment">//将 1 绑定到 x</span></span><br><span class="line">console.log(<span class="func"><span class="keyword">func</span><span class="params">(<span class="number">2</span>)</span></span>);   <span class="comment">//2 绑定到 y 输出 1+2 ＝ 3</span></span><br></pre></td></tr></table></figure>
<p>我们也可以通过 apply 和 call 来模拟 bind 函数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>,    <span class="comment">//保存原函数</span></span><br><span class="line">		context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">//获得 bind 的第一个参数，上下文对象</span></span><br><span class="line">		args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">//剩余参数转换为数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="comment">//调用apply将context绑定在this上，并且将原函数的参数和bind的参数合并成一个数组做参数</span></span><br><span class="line">		self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.name );	<span class="comment">//hzq</span></span><br><span class="line">	<span class="built_in">console</span>.log( x + y + z );	<span class="comment">//6</span></span><br><span class="line">&#125;.bind(&#123;name:<span class="string">"hzq"</span>&#125;, <span class="number">1</span>);</span><br><span class="line">func(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面我们模拟的 bind 中，我们通过 apply 和 call 借用了数组的 shift、slice和 concat 方法，因为arguments是一个类数组对象，虽然它也有下标，也有length属性，但是它仍然不是数组对象，无法使用Array原型对象的相对应方法，使用apply和call可以让我们借用这些方法，例如我们可以像下面一样操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 将arguments转换为一个真正的数组</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shif.call(<span class="built_in">arguments</span>) <span class="comment">//arguments的第一个元素出列</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(<span class="built_in">arguments</span>,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//给arguments对象增加三个元素</span></span><br></pre></td></tr></table></figure>
<p>原因就是这些数组的方法中都使用了 this，例如V8引擎中的Array.prototype.push的实现：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32( <span class="keyword">this</span>.length );   <span class="comment">//获得原数组长度</span></span><br><span class="line">    <span class="keyword">var</span> m = %_ArgumentsLength();        <span class="comment">//获得push参数的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">this</span>[ i + n] = %_Arguments( i );    <span class="comment">//  复制元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = m + n;    <span class="comment">//重置数组 length 长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;     <span class="comment">//返回长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到，并不是所有对象都可以借用这个push方法的，这个对象得有 length 属性，并且可读写属性。所以下面这种情况也是可行的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">	length: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.push.apply(obj,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);	<span class="comment">//Object &#123;0: 0, 1: 1, 2: 2, 3: 3, length: 4&#125;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ECMAScript 3给 Function 的原型中定义了两个方法，分别是 Function.prototype.call 和 Function.prototype.apply。它们两个都可以改变函数体内 this的指向，区别仅在第二个参数不同。</p>
<p>apply]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
</feed>
