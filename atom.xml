<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ICEDOM]]></title>
  <subtitle><![CDATA[ICEDOM]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://imhzq.com/"/>
  <updated>2015-12-14T17:32:45.000Z</updated>
  <id>http://imhzq.com/</id>
  
  <author>
    <name><![CDATA[sumizu]]></name>
    <email><![CDATA[simlesos@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[图片格式]]></title>
    <link href="http://imhzq.com/2015/12/08/20151207_image-type/"/>
    <id>http://imhzq.com/2015/12/08/20151207_image-type/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-14T17:32:45.000Z</updated>
    <content type="html"><![CDATA[<p>网页中充斥着各种图片格式，它们有什么区别？应用场景分别是什么？欢迎收看本期今日xx :-)</p>
<p>我们常见的图片格式有，gif,png,jpeg,ico这几种，哦对，还有google的 <a href="https://zh.wikipedia.org/wiki/WebP" target="_blank" rel="external">WebP</a>。使用图片也要遵照基本法的，咱们先讲图片法。不同格式图像都有着自己的特点，这些特点决定了我们何时何地如何去使用它们。</p>
<h2 id="u56FE_u5F62"><a href="#u56FE_u5F62" class="headerlink" title="图形"></a>图形</h2><p>网站的 logo、图标、草图等都属于图形，这些图像通常由连续的线条或其他尖锐的颜色过渡组成，颜色数量相对较少</p>
<h2 id="u7167_u7247"><a href="#u7167_u7247" class="headerlink" title="照片"></a>照片</h2><p>照片通常包含比较丰富的颜色，并且包含平滑的颜色过渡和渐变。</p>
<p>就图像格式而言，GIF通常用来显示图形，而jpeg更适合显示照片，png两者都合适。</p>
<h2 id="u50CF_u7D20_u548CRGB"><a href="#u50CF_u7D20_u548CRGB" class="headerlink" title="像素和RGB"></a>像素和RGB</h2><p>图像由像素组成，像素是图像最小的信息单元。有多种颜色模型可以来描述像素，比如 RGB、RGBa等。</p>
<h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>RGB颜色模型，采用包含红(R)、绿(G)、蓝(B)的数量多少的方式来描述一个像素。R、G、B被称作通道，每种通道的强度范围在 0~255 之间。我们在CSS和HTML中实用的十六禁止的通道值，范围从 00~FF，将强度不同的成分合在一起就组成了不同的颜色。</p>
<h3 id="RGBa"><a href="#RGBa" class="headerlink" title="RGBa"></a>RGBa</h3><p>RGBa 并非一种截然不同的颜色模型，而是在 RGB 的基础上做了扩展。额外的成分 a 代表 alpha（可变的） 透明，值的范围也是0~255，不同的程序和库会以不同的方式展示比如0～100%。</p>
<h3 id="u771F_u8272_u5F69_u56FE_u50CF_u548C_u8C03_u8272_u677F_u56FE_u50CF_u683C_u5F0F"><a href="#u771F_u8272_u5F69_u56FE_u50CF_u548C_u8C03_u8272_u677F_u56FE_u50CF_u683C_u5F0F" class="headerlink" title="真色彩图像和调色板图像格式"></a>真色彩图像和调色板图像格式</h3><p>使用RGB颜色模型究竟可以展现 256<em>256</em>256＝16777216 种颜色。可以支持这么多种颜色的图片格式叫真色彩图像格式，比如jpeg和png的真色彩类型。</p>
<p>为了在存储图像信息时节省一些空间，有种技术可以将图像中各种不同的颜色提取出来建立一个表，这个表叫做调色板（也叫索引）。有了这个颜色表，就可以通过将调色板中的条目和每个像素重新匹配。达到重绘整个图像的目的。</p>
<p>gif和png8会限制调色板做多只能包含 256 种颜色，这不是说只可以从 256 中定义好的颜色中选择，而是你可以从 1600w＋的颜色中选择你需要的颜色，但是一个图片只能包含 256 种颜色。</p>
<h3 id="u9694_u884C_u626B_u63CF"><a href="#u9694_u884C_u626B_u63CF" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>当网速比较慢的时候，大图会随着下载进度逐行显示。为了提高用户体验，部分图像格式支持对那些连续采样的图像进行隔行扫描。隔行扫描(又被称作渐进式图片)可以让用户在图片下载完成前，看到一个模糊的版本，从而在用户心理上消除页面加载缓慢的感觉。具体可以参考张鑫旭大大的这片博文 <a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片及其相关</a></p>
<p>##不同格式图像的特性<br>看完上面的资料后，咱们来看看gif、jpeg和 png 这 3种格式的区别。</p>
<p>###GIF<br>gif是一种调色板图片格式，只能包含256种颜色。</p>
<p>####透明<br>gif 允许一个二进制类型的透明，要没每个像素要么是完全透明要么就是完全不透明。透明也会占用一个调色板条目，也就只剩下255种颜色可选了。</p>
<p>####动画<br>gif 格式支持动画。</p>
<p>####无损<br>gif也是无损的，也就是说你可以打开任意一个 gif 文件，做一些修改，保存关闭时不会损失任何质量。</p>
<p>####逐行扫描<br>生成GIF会使用一个LZW压缩算法来减小文件大小，当压缩gif时，会从上到下一行一行的对像素进行扫描。这种情况下，当图片在水平方向有很多重复颜色时，可以获得更好的压缩效果。</p>
<p>####隔行扫描<br>gif支持可选的隔行扫描，由于gif有256色的限制，所以不适合显示照片。gif更适合显示图形，但是png8才是显示图形最佳格式。所以，只有当使用动画时才应该使用 gif。</p>
<p>###JPEG<br>jpeg是一种有损压缩格式，用户可以设置自定义质量级别，这个级别决定了有多少信息会被丢弃。质量级别从0～100，但是就算设置为100，也同样会有一定程度的质量损耗。</p>
<p>当你要对图片进行多项编辑操作室，最好使用无损的图像格式来保存中间结果，然后在完成所有操作后，另存为jpeg格式，否则，你将会在每次保存都丢失一些质量。</p>
<p>有些操作是无损的：</p>
<ol>
<li>旋转（只有在旋转90度、180度、270度的情况下）</li>
<li>裁剪</li>
<li>翻转 (水平或垂直)</li>
<li>从标准模式切换至渐进模式，反之亦然</li>
<li>编辑图像的元数据（在优化jpeg图像时极为重要）</li>
</ol>
<p>####透明和动画<br>jpeg不支持透明和动画</p>
<p>####隔行扫描<br>渐进式jpeg<a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片及其相关</a></p>
<h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p>为了弥补gif格式的缺点，并规避 LZW 算法的专利问题，PNG应运而生。</p>
<p>####PNG8<br>调色板PNG的别称</p>
<p>####PNG24<br>真色彩PNG的别称，但是不包括 alpha 通道</p>
<p>####PNG32<br>真色彩PNG的别称，包括 alpha 通道</p>
<p>####透明<br>PNG支持完全的 alpha 透明，IE6中会出现问题</p>
<p>####动画<br>有相关实验的实际应用，但还没有跨浏览器的解决方案</p>
<p>####无损<br>与jpeg不，png是一种无损的图像格式：多次编辑不会降低其质量，这使得用真色彩png来保存jpeg的修改过程的中间产物非常合适。</p>
<p>####逐行扫描<br>和gif格式一样，相对于那些垂直方向有重复颜色的图像来说，png格式对那些水平方向上有重复颜色的图像压缩比更高。so，sprite水平摆放会获得更小的尺寸。</p>
<p>####隔行扫描<br>png支持隔行扫描，并使用了比gif更先进的算法，它允许对真实图像进行更好的“预览”，但是大小会更大些。</p>
<p>####和 GIF 对比</p>
<p>除了不支持动画外，调色板png 拥有gif所有的功能。此外，它还支持 alpha 透明，并且通常压缩比更高，文件大小更小。所以 ，应该尽可能的使用 png8替代 gif。</p>
<p>有一个例外是颜色数量较少的小图片，gif的压缩率会更高些。但是这种小图一般都被放在 css sprite 中，因为 http 请求的开销已经大大超过节省那点带宽，而且用png保存sprite图像可以获得更高的压缩率。</p>
<p>####和 jpeg 对比<br>当图像中颜色超过 256中时，需要使用真色彩图像格式。jpeg的压缩比更高，而且一般来说，jpeg也是照片存储的实际标准。但由于 jpeg 是有损的，而且在清晰的颜色过渡周围会有大色块，因此下面情况使用PNG更合适：</p>
<ol>
<li>当图片颜色<code>略微</code>超过256，可以在不损耗人和可见质量的前提下，将图片转化为png8格式。令人惊奇的是，有时候，就算你剥离了 1000种以上的颜色，都不会注意到图片中的所发生的变化</li>
<li>当大色块变得不能接受的时候，比如包含很色颜色的图像或软件菜单的截图，这时候png更好。</li>
</ol>
<h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p>WebP最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。2011年11月8日，Google开始让WebP支持无损压缩和透明色的功能。但目前只有 chrome 和 opera 浏览器支持原生 WebP 格式。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>###GIF</p>
<p>####优点:</p>
<ul>
<li>动画</li>
<li>无损</li>
</ul>
<p>####缺点：</p>
<ul>
<li>256色</li>
<li>压缩比不如 png8（颜色少的小图虽然压缩比比 png8高，但是 sprite 格式的 png 更优）</li>
<li>不支持透明</li>
</ul>
<p>###JPEG</p>
<p>####优点：</p>
<ul>
<li>真色彩</li>
<li>压缩比可调<br>####缺点：</li>
<li>有损</li>
<li>不支持透明和动画</li>
</ul>
<p>###PNG8</p>
<p>####优点：</p>
<ul>
<li>无损</li>
<li>压缩比高</li>
<li>支持 alpha 通道<br>####缺点：</li>
<li>256色</li>
</ul>
<p>###PNG24/PNG32</p>
<p>####优点：</p>
<ul>
<li>无损</li>
<li>真色彩</li>
<li>支持 alpha 通道<br>####缺点：</li>
<li>图片较大</li>
</ul>
<p>###实际应用<br>这些格式没有孰优孰略，完全看需求：<br>jpeg通常用在颜色复杂、但不要求特别精细的图片上，如照片、宣传图、背景等。<br>png通常用在颜色复杂并且要求特别精细或者有透明需求的图片上，如复杂的logo、图标等。由于无损还可以当做“原图”来存档使用。<br>png8在png的基础上“减去”颜色复杂。<br>gif由于静态部分可以被png8代替，所以通常只用于简单的动画。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>网页中充斥着各种图片格式，它们有什么区别？应用场景分别是什么？欢迎收看本期今日xx :-)</p>
<p>我们常见的图片格式有，gif,png,jpeg,ico这几种，哦对，还有google的 <a href="https://zh.wikipedia.org/wiki/W]]>
    </summary>
    
      <category term="前端 图片" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF-%E5%9B%BE%E7%89%87/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[call和apply]]></title>
    <link href="http://imhzq.com/2015/12/06/20151206_js-call-apply/"/>
    <id>http://imhzq.com/2015/12/06/20151206_js-call-apply/</id>
    <published>2015-12-05T16:00:00.000Z</published>
    <updated>2015-12-14T17:32:45.000Z</updated>
    <content type="html"><![CDATA[<p>ECMAScript 3给 Function 的原型中定义了两个方法，分别是 Function.prototype.call 和 Function.prototype.apply。它们两个都可以改变函数体内 this的指向，区别仅在第二个参数不同。</p>
<p>apply 接受两个参数，第一个参数表示函数体内的 this 的指向；第二个函数表示一个参数数组，也可以是类数组，表示传递给这个函数的参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name: <span class="string">"obj1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">"obj2"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">": my numbers is "</span> + [a, b, c]);  </span><br><span class="line">&#125;</span><br><span class="line">sayNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);	<span class="comment">//window: my numbers is 1,2,3</span></span><br><span class="line">sayNumbers.call(obj1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);		<span class="comment">//obj1: my numbers is 1,2,3</span></span><br><span class="line">sayNumbers.apply(obj2, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);	<span class="comment">//obj2: my numbers is 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>因为 function 的参数就保存在一个 arguments 类数组中，所以 apply 会常用些。这里我们展示了 apply 和 call 的第一个用法：改变 this 的指向，这里我们使用 sayNumbers.call(obj1, 1, 2, 3)，函数体内的 this 就指向的是 obj1，同理 sayNumbers.apply(obj2, [1, 2, 3]) 中的 this 指向的就是 obj2。</p>
<p>大家应该知道在 ECMAScript 5 中新增了一个 Function.prototype.bind 函数，这个方法的作用和call 和 apply 很相似，就是将函数中的this 绑定到一个对象上。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	name: <span class="string">"obj1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;.bind(obj1);</span><br><span class="line">sayName();      <span class="comment">// obj1</span></span><br></pre></td></tr></table></figure>
<p>大家会发现这个好像个 call 和 apply 的功能几乎一样啊！然而，如果一样也就没有 bind 存在的理由了，bind 还有第二个参数，除了第一个实参外，传入 bind 的其他实参也会绑定至相对应的实参，这被称作柯里化。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="title">function</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;.bind(null, <span class="number">1</span>);    <span class="comment">//将 1 绑定到 x</span></span><br><span class="line">console.log(<span class="func"><span class="keyword">func</span><span class="params">(<span class="number">2</span>)</span></span>);   <span class="comment">//2 绑定到 y 输出 1+2 ＝ 3</span></span><br></pre></td></tr></table></figure>
<p>我们也可以通过 apply 和 call 来模拟 bind 函数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>,    <span class="comment">//保存原函数</span></span><br><span class="line">		context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">//获得 bind 的第一个参数，上下文对象</span></span><br><span class="line">		args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">//剩余参数转换为数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="comment">//调用apply将context绑定在this上，并且将原函数的参数和bind的参数合并成一个数组做参数</span></span><br><span class="line">		self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.name );	<span class="comment">//hzq</span></span><br><span class="line">	<span class="built_in">console</span>.log( x + y + z );	<span class="comment">//6</span></span><br><span class="line">&#125;.bind(&#123;name:<span class="string">"hzq"</span>&#125;, <span class="number">1</span>);</span><br><span class="line">func(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面我们模拟的 bind 中，我们通过 apply 和 call 借用了数组的 shift、slice和 concat 方法，因为arguments是一个类数组对象，虽然它也有下标，也有length属性，但是它仍然不是数组对象，无法使用Array原型对象的相对应方法，使用apply和call可以让我们借用这些方法，例如我们可以像下面一样操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 将arguments转换为一个真正的数组</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shif.call(<span class="built_in">arguments</span>) <span class="comment">//arguments的第一个元素出列</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(<span class="built_in">arguments</span>,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//给arguments对象增加三个元素</span></span><br></pre></td></tr></table></figure>
<p>原因就是这些数组的方法中都使用了 this，例如V8引擎中的Array.prototype.push的实现：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32( <span class="keyword">this</span>.length );   <span class="comment">//获得原数组长度</span></span><br><span class="line">    <span class="keyword">var</span> m = %_ArgumentsLength();        <span class="comment">//获得push参数的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">this</span>[ i + n] = %_Arguments( i );    <span class="comment">//  复制元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = m + n;    <span class="comment">//重置数组 length 长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;     <span class="comment">//返回长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到，并不是所有对象都可以借用这个push方法的，这个对象得有 length 属性，并且可读写属性。所以下面这种情况也是可行的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">	length: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.push.apply(obj,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);	<span class="comment">//Object &#123;0: 0, 1: 1, 2: 2, 3: 3, length: 4&#125;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ECMAScript 3给 Function 的原型中定义了两个方法，分别是 Function.prototype.call 和 Function.prototype.apply。它们两个都可以改变函数体内 this的指向，区别仅在第二个参数不同。</p>
<p>apply]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js中的this]]></title>
    <link href="http://imhzq.com/2015/12/05/20151205_js-this/"/>
    <id>http://imhzq.com/2015/12/05/20151205_js-this/</id>
    <published>2015-12-04T16:00:00.000Z</published>
    <updated>2015-12-14T17:32:45.000Z</updated>
    <content type="html"><![CDATA[<p>javascript 的 this 虽然和其他语言一样总是指向一个对象，但是具体指向哪个对象是在运行时基于执行环境动态绑定的，并不是函数被声明时的环境。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>因为 with 和 eval 不常使用，这里不再讨论。实际应用中，this 的指向情况大致可分为：</p>
<ol>
<li>作为对象的方法被调用</li>
<li>作为普通数调用</li>
<li>构造函数中调用</li>
</ol>
<h3 id="u4F5C_u4E3A_u5BF9_u8C61_u7684_u65B9_u6CD5_u8C03_u7528"><a href="#u4F5C_u4E3A_u5BF9_u8C61_u7684_u65B9_u6CD5_u8C03_u7528" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为对象的方法调用时，this 指向该对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.saying = <span class="string">"大家都别吵了，给我赵日天一个面子！"</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        saying: <span class="string">"我赵日天第一个表示不服！！"</span>,</span><br><span class="line">        getSaying: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.saying;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getSaying());   <span class="comment">//我赵日天第一个表示不服！！</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F5C_u4E3A_u666E_u901A_u51FD_u6570_u8C03_u7528"><a href="#u4F5C_u4E3A_u666E_u901A_u51FD_u6570_u8C03_u7528" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h3><p>普通函数中的 this 总是指向全局对象，在浏览器中就是 window 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getSaying2 = obj.getSaying;</span><br><span class="line"><span class="built_in">console</span>.log(getSaying2());   <span class="comment">//大家都别吵了，给我赵日天一个面子！</span></span><br></pre></td></tr></table></figure>
<p>当调用 obj.getSaying 时，getSaying 方法是作为 obj 对象的属性被调用的，this 指向 obj。</p>
<p>当通过另一个变量 getSaying2 来引用 obj.getSaying 并调用时，是普通函数调用，this 指向 window 对象。</p>
<p>这点经常会引发一个错误，比如，我们每次写 document.getElementById 会觉得太长了，可不可以替换成成一个短一些的函数，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">getId(<span class="string">"box"</span>);   <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>
<p>这段代码会报错，因为 document.getElementById 方法内部需要用到 this。这个 this 本来应该指向 document 的，但我们通过引用的方式，再调用就成了普通函数调用了 this 指向了 window 而不是 document。</p>
<p>我们可以通过apply 和 call 改变 this 的指向来修复。</p>
<h3 id="u4F5C_u4E3A_u6784_u9020_u51FD_u6570_u8C03_u7528"><a href="#u4F5C_u4E3A_u6784_u9020_u51FD_u6570_u8C03_u7528" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>javascript 中没有类，但是可以从构造器中创建对象，并且提供了 new 运算符，使得看起来更像是在创建类。基本上除了一些内置函数外，大部分函数都可以当作构造函数使用，构造函数和普通函数一模一样，区别就在于被调用的方式。当用 new 运算符调用函数时，该函数就是构造函数，并会返回一个对象，通常情况下，其中的 this 指向的就是这个构造函数返回的那个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">"赵日天"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 赵日天</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>javascript 的 this 虽然和其他语言一样总是指向一个对象，但是具体指向哪个对象是在运行时基于执行环境动态绑定的，并不是函数被声明时的环境。</p>
<h2 id="this"><a href="#this" class="headerlink" title="]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="http://imhzq.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拥抱自由shadowsocks]]></title>
    <link href="http://imhzq.com/2015/12/04/20151204_use-shadowsocks/"/>
    <id>http://imhzq.com/2015/12/04/20151204_use-shadowsocks/</id>
    <published>2015-12-03T16:00:00.000Z</published>
    <updated>2015-12-12T15:45:25.000Z</updated>
    <content type="html"><![CDATA[<p>从 2013 年开始用 <a href="http://jproxy.io/" target="_blank" rel="external">jproxy</a> 已经3年了，最终她也没能逃过魔掌:( ，感谢 <a href="http://weibo.com/xiaojay#_rnd1449301836815" target="_blank" rel="external">xiaojay</a> 大大期间不断的维护！Google 不能访问就好像断网了一样难受，回想那几个小时简直痛不欲生啊！用百度简直想吐，竞价排名去死吧！思来想去，一不做二不休，自己搭个⬆吧！</p>
<h2 id="u8D2D_u4E70_VPS"><a href="#u8D2D_u4E70_VPS" class="headerlink" title="购买 VPS"></a>购买 VPS</h2><p>选来选去，还是选了<a href="https://bandwagonhost.com/index.php" target="_blank" rel="external">搬瓦工</a>，买了$19.99 一年的套餐，配置如下：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RAM</span>: <span class="string">256MB</span></span><br><span class="line"><span class="attribute">Disk</span>: <span class="string">10GB SSD</span></span><br><span class="line"><span class="attribute">Bandwidth</span>: <span class="string">550GB</span></span><br></pre></td></tr></table></figure></p>
<p>对了，在搬瓦工的主页右键显示网页源码，里面有段注释：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Try this promo code: IAMSMART5C48JJ --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>购买的时候，可以加进去。我试了，最大的优惠额度是 5%，支付的时候可以用支付宝支付～</p>
<h2 id="u8BBE_u7F6E_u4E3B_u673A"><a href="#u8BBE_u7F6E_u4E3B_u673A" class="headerlink" title="设置主机"></a>设置主机</h2><p>进入主机控制面板</p>
<h3 id="u66F4_u6362_u7CFB_u7EDF"><a href="#u66F4_u6362_u7CFB_u7EDF" class="headerlink" title="更换系统"></a>更换系统</h3><p>选择 Install new OS，更换新系统，我选择的是  centos-6-x86_64-minimal 内存占用只有 7m 左右，毕竟内存只有 256m，能少占点就少占点:-)</p>
<h3 id="u83B7_u53D6ROOT_u7528_u6237_u5BC6_u7801"><a href="#u83B7_u53D6ROOT_u7528_u6237_u5BC6_u7801" class="headerlink" title="获取ROOT用户密码"></a>获取ROOT用户密码</h3><p>选择 Root Password modification 就可以过的 root 用户密码了，ssh登陆进去<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -p <span class="number">3000</span></span><br></pre></td></tr></table></figure></p>
<p>修改 root 用户密码，创建新用户等等～</p>
<h3 id="u4F7F_u7528_u642C_u74E6_u5DE5_u7684Shadowsocks_Server"><a href="#u4F7F_u7528_u642C_u74E6_u5DE5_u7684Shadowsocks_Server" class="headerlink" title="使用搬瓦工的Shadowsocks Server"></a>使用搬瓦工的Shadowsocks Server</h3><p>选择 Shadowsocks Server，安装 shadowsocks 服务，下载对应的 <a href="https://github.com/shadowsocks" target="_blank" rel="external">shadowscoks客户端</a>,配置上相关参数即可，相当简单！</p>
<h3 id="u4F7F_u7528_shadowsocks-libev"><a href="#u4F7F_u7528_shadowsocks-libev" class="headerlink" title="使用 shadowsocks-libev"></a>使用 shadowsocks-libev</h3><p>shadowsocks-libev 是一个 shadowsocks 协议的轻量级实现，是 shadowsocks-android, shadowsocks-ios 以及 shadowsocks-openwrt 的上游项目。其具有以下特点：</p>
<ol>
<li>体积小巧，静态编译并打包后只有 100 KB。</li>
<li>高并发，基于 libev 实现的异步 I/O，以及基于线程池的异步 DNS，同时连接数可上万。</li>
<li>低资源占用，几乎不占用 CPU 资源，服务器端内存占用一般在 3MB 左右。</li>
<li>跨平台，适用于所有常见硬件平台，已测试通过的包括 x86，ARM 和 MIPS。也适用于大部分 POSIX 的操作系统或平台，包括 Linux，OS X 和 gwin 等。</li>
<li>协议及配置兼容，完全兼容 shadowsocks 协议，且兼容标准实现中的 JSON 风格配置文件，可与任意实现的 shadowsocks 端或服务端搭配使用。</li>
</ol>
<h4 id="u5B89_u88C5_u5FC5_u8981_u7EC4_u4EF6"><a href="#u5B89_u88C5_u5FC5_u8981_u7EC4_u4EF6" class="headerlink" title="安装必要组件"></a>安装必要组件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos: yum <span class="operator"><span class="keyword">install</span> <span class="keyword">build</span>-essential autoconf libtool openssl-devel gcc -y</span><br><span class="line">        yum <span class="keyword">install</span> git -y</span></span><br></pre></td></tr></table></figure>
<h4 id="u4E0B_u8F7D_u53CA_u7F16_u8BD1_shadowsocks-libev"><a href="#u4E0B_u8F7D_u53CA_u7F16_u8BD1_shadowsocks-libev" class="headerlink" title="下载及编译 shadowsocks-libev"></a>下载及编译 shadowsocks-libev</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/madeye/shadowsocks-libev.git</span><br><span class="line"><span class="keyword">cd</span> shadowsocks-libev</span><br><span class="line">./configure</span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFA_ssconfig-json__u6587_u4EF6"><a href="#u521B_u5EFA_ssconfig-json__u6587_u4EF6" class="headerlink" title="创建 ssconfig.json 文件"></a>创建 ssconfig.json 文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"server"</span>:<span class="string">"servier_ip"</span>,   <span class="preprocessor"># 服务器IP</span></span><br><span class="line">        <span class="string">"server_port"</span>:<span class="number">65000</span>,     <span class="preprocessor"># ss服务器所使用的端口号，建议改到<span class="number">30000</span>-<span class="number">60000</span></span></span><br><span class="line">        <span class="string">"password"</span>:<span class="string">"password"</span>,   <span class="preprocessor"># ss服务器密码，轻易不要分享</span></span><br><span class="line">        <span class="string">"timeout"</span>:<span class="number">60</span>,            <span class="preprocessor"># 超时时间，建议设置为<span class="number">60</span></span></span><br><span class="line">        <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>   <span class="preprocessor"># 加密方式，需要和客户端配合设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u8FD0_u884C"><a href="#u8FD0_u884C" class="headerlink" title="运行"></a>运行</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>ss-server -c ~<span class="regexp">/ssconfig.json -f /</span>tmp<span class="regexp">/ss1.pid</span></span><br></pre></td></tr></table></figure>
<p>这时候，打开客户端，设置相关参数就可以了，之后，可以用非 ROOT 用户运行 ss<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 创建 hzq 用户</span></span><br><span class="line">useradd hzq</span><br><span class="line"><span class="preprocessor"># 为hzq创建密码</span></span><br><span class="line">passwd hzq</span><br><span class="line">&gt; 输入两次密码</span><br><span class="line"><span class="preprocessor"># 切换用户至hzq</span></span><br><span class="line">su - hzq</span><br><span class="line"><span class="preprocessor"># 在主目录创建第一个配置文件，配置格式请参考`使用配置文件运行`一节</span></span><br><span class="line">vim ~/ssconfig.json</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 保存完毕即可立即运行</span></span><br><span class="line">/usr/local/bin/ss-server -c ~/ssconfig.json -f /tmp/ss1.pid</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 设置开启自启动</span></span><br><span class="line"><span class="preprocessor"># 我们先切换至root用户</span></span><br><span class="line">su - root</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 接着在启动脚本里加入启动命令</span></span><br><span class="line"><span class="preprocessor"># 指定ss以用户hzq的权限运行</span></span><br><span class="line"><span class="preprocessor"># 执行下面的命令时一定注意文件路径是否正确</span></span><br><span class="line">echo <span class="string">"su - hzq -c \"/usr/local/bin/ss-server -c /home/hzq/config1.json -f /tmp/ss1.pid\""</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>打开 Google ，熟悉的页面又出来了，终于有网了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从 2013 年开始用 <a href="http://jproxy.io/" target="_blank" rel="external">jproxy</a> 已经3年了，最终她也没能逃过魔掌:( ，感谢 <a href="http://weibo.com/xiaoja]]>
    </summary>
    
      <category term="生活" scheme="http://imhzq.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Freedom" scheme="http://imhzq.com/categories/Freedom/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[事件委托]]></title>
    <link href="http://imhzq.com/2015/11/09/20151109_Event-delegation/"/>
    <id>http://imhzq.com/2015/11/09/20151109_Event-delegation/</id>
    <published>2015-11-08T16:00:00.000Z</published>
    <updated>2015-12-12T16:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的 DOM 元素越多，应用程序就越慢。特别是事件绑定通常发生在 onload 时，此时对每一个富交互应用的网页来说都是一个拥堵的时刻。事件绑定占用了处理事件，而且，浏览器需要跟踪每个事件处理器，这也会占用更多的内存。</p>
<p>一种简单的 DOM 事件处理技术就是事件委托。</p>
<p>根据 DOM 标准，每个事件都要经历三个阶段</p>
<ol>
<li>捕获（IE不支持）</li>
<li>到达目标</li>
<li>冒泡 </li>
</ol>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/646E5068-FD77-4934-8981-04596183F3F1.png" alt="img"></p>
<p>对事件委托来说，冒泡就够了，比如说我们想要给下面这段代码中每个 a 标签增加一个点击事件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"links"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item1<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item2<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item3<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item4<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>item5<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以把 onclick 事件绑定在 ul 元素上，然后通过 event.target 获得当前冒泡事件对象，再根据业务逻辑判断是否是目标元素的点击事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"links"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName !== <span class="string">"A"</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(target.nodeName + <span class="string">": "</span> + target.textContent);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>(list.addEventListener)&#123;</span><br><span class="line">    list.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(list.attachEvent)&#123;</span><br><span class="line">    list.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    list[<span class="string">"onclick"</span>] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以简单的封装个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     * @param dom 委托对象</span><br><span class="line">     * @param nodeName 目标元素 nodeName</span><br><span class="line">     * @param type 事件类型</span><br><span class="line">     * @param cb 事件执行函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">delegation</span>(<span class="params">dom,nodeName, type, cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            e = e || <span class="built_in">window</span>.event;</span><br><span class="line">            <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">            <span class="keyword">if</span>(target.nodeName !== nodeName.toUpperCase()) <span class="keyword">return</span>;</span><br><span class="line">            cb(e);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> e.preventDefault === <span class="string">'function'</span>)&#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">                e.stopPropagation();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                e.returnValue = <span class="literal">false</span>;</span><br><span class="line">                e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(dom.addEventListener)&#123;</span><br><span class="line">            dom.addEventListener(type, handler,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent)&#123;</span><br><span class="line">            dom.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dom[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用起来，直接调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.getElementById(<span class="string">"links"</span>);</span><br><span class="line">delegation(links, <span class="string">"a"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">    <span class="built_in">console</span>.log(target.nodeName + <span class="string">":"</span> + target.textContent);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>去除一些冗长的浏览器兼容代码后，就会变的干净许多！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的 DOM 元素越多，应用程序就越慢。特别是事件绑定通常发生在 onload 时，]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS选择器优化]]></title>
    <link href="http://imhzq.com/2015/11/08/20151108_simplifying-css-selectors/"/>
    <id>http://imhzq.com/2015/11/08/20151108_simplifying-css-selectors/</id>
    <published>2015-11-07T16:00:00.000Z</published>
    <updated>2015-12-12T16:06:20.000Z</updated>
    <content type="html"><![CDATA[<p>样式系统从最右边的选择符开始向左边匹配规则。只要当前选择符的左边还有其他的选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。</p>
<h2 id="u6700_u53F3_u8FB9_u4F18_u5148"><a href="#u6700_u53F3_u8FB9_u4F18_u5148" class="headerlink" title="最右边优先"></a>最右边优先</h2><p>我最初的觉得 CSS 选择符一定也是从左到右匹配规则的，就像下面这个例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#header</span> <span class="tag">li</span><span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<p>先找到 id 为 header 的元素，然后把这个样式应用到子元素 li 上。我们知道只有一个 id 为 header 的元素，并且它只有几个 li 元素，这个选择符应该是相当高效的才对。</p>
<p>事实上 <em>CSS 选择符是从右到左进行匹配的。</em> 那么回头看上面那个看似高效的的选择符实际上开销相当高，浏览器必须遍历页面上每个 li 元素并确定其父元素的 id 是否是 header。</p>
<h2 id="u5982_u4F55_u7F16_u5199_u9AD8_u6548_u7684CSS_u9009_u62E9_u7B26"><a href="#u5982_u4F55_u7F16_u5199_u9AD8_u6548_u7684CSS_u9009_u62E9_u7B26" class="headerlink" title="如何编写高效的CSS选择符"></a>如何编写高效的CSS选择符</h2><h3 id="u907F_u514D_u4F7F_u7528_u901A_u914D_u89C4_u5219"><a href="#u907F_u514D_u4F7F_u7528_u901A_u914D_u89C4_u5219" class="headerlink" title="避免使用通配规则"></a>避免使用通配规则</h3><p>除了传统意义的通配符外，相邻兄弟选择符、子选择符、后代选择符和属性选择符都应该避免使用，推荐使用 ID、类和标签选择器</p>
<h3 id="u4E0D_u8981_u9650_u5B9A_ID__u9009_u62E9_u7B26"><a href="#u4E0D_u8981_u9650_u5B9A_ID__u9009_u62E9_u7B26" class="headerlink" title="不要限定 ID 选择符"></a>不要限定 ID 选择符</h3><p>在页面中一个指定的 ID 只对应一个元素，没有必要添加额外的选择符</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span><span class="id">#header</span><span class="rules">&#123;&#125;</span> <span class="comment">/* 这样是没必要的，应该简化为 #header */</span></span><br></pre></td></tr></table></figure>
<h3 id="u4E0D_u8981_u9650_u5B9A_u7C7B_u9009_u62E9_u7B26"><a href="#u4E0D_u8981_u9650_u5B9A_u7C7B_u9009_u62E9_u7B26" class="headerlink" title="不要限定类选择符"></a>不要限定类选择符</h3><p>不要用具体的标签限定类选择符，而是根据实际情况对累名进行扩展。例如，把 li.item 改成 .li-item</p>
<h3 id="u8BA9_u89C4_u5219_u8D8A_u5177_u4F53_u8D8A_u597D"><a href="#u8BA9_u89C4_u5219_u8D8A_u5177_u4F53_u8D8A_u597D" class="headerlink" title="让规则越具体越好"></a>让规则越具体越好</h3><p>不要编写 ul li a 这样的长选择符，最好是创建一个像 .li-item 这样的类，并把它添加到适当的元素上</p>
<h3 id="u907F_u514D_u4F7F_u7528_u540E_u4EE3_u9009_u62E9_u7B26"><a href="#u907F_u514D_u4F7F_u7528_u540E_u4EE3_u9009_u62E9_u7B26" class="headerlink" title="避免使用后代选择符"></a>避免使用后代选择符</h3><p>通常处理后代选择符的开销是最高的，而是用梓煊泽肤也可以得到想要的结果，并且更高效。</p>
<h3 id="u907F_u514D_u4F7F_u7528_u6807_u7B7E_uFF0D_u5B50_u9009_u62E9_u7B26"><a href="#u907F_u514D_u4F7F_u7528_u6807_u7B7E_uFF0D_u5B50_u9009_u62E9_u7B26" class="headerlink" title="避免使用标签－子选择符"></a>避免使用标签－子选择符</h3><p>如果有像 #header &gt; li &gt; a 这样的基于标签的子选择符，那么应该使用一个类来关联每个标签元素。</p>
<h3 id="u8D28_u7591_u5B50_u9009_u62E9_u7B26_u7684_u6240_u6709_u7528_u9014"><a href="#u8D28_u7591_u5B50_u9009_u62E9_u7B26_u7684_u6240_u6709_u7528_u9014" class="headerlink" title="质疑子选择符的所有用途"></a>质疑子选择符的所有用途</h3><p>检查所有使用子选择符的地方，然后尽可能用具体的类取代它们。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>样式系统从最右边的选择符开始向左边匹配规则。只要当前选择符的左边还有其他的选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。</p>
<h2 id="u6700_u53F3_u8FB9_u4F18_u5148"><a href="#u6700]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当line-height小于font-size时发生了什么]]></title>
    <link href="http://imhzq.com/2015/11/07/20151107_talk-line-height/"/>
    <id>http://imhzq.com/2015/11/07/20151107_talk-line-height/</id>
    <published>2015-11-06T16:00:00.000Z</published>
    <updated>2015-12-12T15:49:20.000Z</updated>
    <content type="html"><![CDATA[<p>最近在看 line-height 的时候,当 line-height 大于 font-size 时大家都明白，那如果 line-height 小于 font-size 时会发生了什么？</p>
<h2 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h2><p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/demo1.png" alt="demo1"></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">box</span>&#123;</span><br><span class="line">    <span class="variable">height</span>: <span class="number">300</span>px;</span><br><span class="line">    <span class="built_in">background</span>-<span class="built_in">color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    font-<span class="built_in">size</span>: <span class="number">16</span>px;</span><br><span class="line">    <span class="built_in">line</span>-<span class="variable">height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">span&#123;</span><br><span class="line">    font-<span class="built_in">size</span>: <span class="number">100</span>px;</span><br><span class="line">    <span class="built_in">line</span>-<span class="variable">height</span>: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"box"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;p&gt;ABCDEFG&lt;span class=<span class="string">"test"</span>&gt;Hello world xxxX&lt;/span&gt;HIGKLMN&lt;/p&gt;</span><br><span class="line">&lt;div class=<span class="string">"box"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>起初，我一直不能明白 20px 的 line-height 减去 100px 的 font-size，得到上下两个半行间距各为 -40px，最后 span 元素的 inline-box 应该是 20px 啊，那为啥 p 元素的 line-box 远远大于这个值啊，难道是内容区将其撑开了？百思不得其姐啊！</p>
<p>又仔细翻阅了下权威指南相关介绍，啊！我果然还是太年轻了，这里我天真的以为两个负的半行间距会导致 span 元素的 inline-box 下沉,然而并不会，我做了个简单的效果图：</p>
<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/demo1-2.png" alt="demo2"></p>
<p>这里可以清楚的看到，蓝色框为 20px 高的 行内框，在元素内容区<code>垂直居中</code>。因为行框定义为行中最高行内框的顶端到行中最低行内框的底端之间的距离，所以蓝色框的顶部到黄色框的底部之间的距离，就是行框的高度了，也就是绿色框的高度了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看 line-height 的时候,当 line-height 大于 font-size 时大家都明白，那如果 line-height 小于 font-size 时会发生了什么？</p>
<h2 id="Demo1"><a href="#Demo1" class="h]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么要用href=javascript:void(0);]]></title>
    <link href="http://imhzq.com/2015/11/02/20151102_way-use-void-in-js/"/>
    <id>http://imhzq.com/2015/11/02/20151102_way-use-void-in-js/</id>
    <published>2015-11-01T16:00:00.000Z</published>
    <updated>2015-12-12T16:11:33.000Z</updated>
    <content type="html"><![CDATA[<p>用了这么久的 <code>href=&quot;javascript:void(0);&quot;</code> 和 <code>href=&quot;javascript:;&quot;</code>,突然被人问：为什么这么写？竟不知如何回答…(果然，我是弱鸡啊!)</p>
<p>使用这种方式，常出现在元素是 a 标签，但是又不想让其打开或刷新网页，比如导航列表里面的当前选中项 <code>&lt;a href=&quot;javascript:;&quot; class=&quot;curr&quot;&gt;1&lt;/a&gt;</code>。</p>
<p>那么究竟为什么这么写呢，<code>href=&quot;javascript:void(0);&quot;</code> 和 <code>herf=&quot;javascript:;&quot;</code> 有什么区别？另外好像 <code>href=&quot;javascript:&quot;</code>这样写也可以啊！</p>
<p>##JavaScript: 协议的 URI</p>
<p>经过一番激烈的搜索后，看到如下解释：</p>
<p>当用户点击一个以 javascript: 协议开头的 URI 时，浏览器会对冒号后面的代码进行求值，然后把求值的结果显示在页面上，这时页面基本上是一大片空白，这通常不是我们想要的。只有当这段代码的求值结果是 undefined 的时候，浏览器才不会去做这件傻事，所以我们经常会用 void 运算符来实现这个需求。像下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:void(0);"</span>&gt;</span></span><br><span class="line">  这个链接点击之后不会做任何事情，如果去掉 void()，</span><br><span class="line">  点击之后整个页面会被替换成一个字符 0。</span><br><span class="line"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:void(document.body.style.backgroundColor='green');"</span>&gt;</span></span><br><span class="line">  点击这个链接会让页面背景变成绿色。</span><br><span class="line"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>焕然大悟啊！<code>void(0)</code>、<code>&quot;&quot;</code>都只是用来返回 <code>undefined</code> 用的，因为 js 分号可以省略，就有了 <code>href=&quot;javascript:&quot;</code> 这样的写法。</p>
<p>那又有疑问了，为啥不直接用 <code>undefined</code>？原因是担心拿到的 <code>undefined</code> 可能不是 <code>undefined</code>，可能是被人重新赋值过的全局变量！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.undefined = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>PS: ES3中，window.undefined 就是一个普通的属性，你可以任意殴打，不对，是任意赋值，但在 ES5 中，window.undefined 变成了一个不可写，不可配置的属性，它的值永远都是 undefined 了，瞬间变的高贵冷艳起来了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用了这么久的 <code>href=&quot;javascript:void(0);&quot;</code> 和 <code>href=&quot;javascript:;&quot;</code>,突然被人问：为什么这么写？竟不知如何回答…(果然，我是弱鸡啊!)</p]]>
    </summary>
    
      <category term="javascript" scheme="http://imhzq.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS的层叠、特殊性和继承]]></title>
    <link href="http://imhzq.com/2015/11/02/20151102_cascading-and-inheritance/"/>
    <id>http://imhzq.com/2015/11/02/20151102_cascading-and-inheritance/</id>
    <published>2015-11-01T16:00:00.000Z</published>
    <updated>2015-12-12T16:06:08.000Z</updated>
    <content type="html"><![CDATA[<p>在一个样式表中要查找同一个元素，我们可以通过多种规则找到。CSS 通过一个成为<code>层叠</code>的过程处理这种冲突。</p>
<h2 id="u5C42_u53E0"><a href="#u5C42_u53E0" class="headerlink" title="层叠"></a>层叠</h2><p>层叠给每个规则分配一个权重,如下:</p>
<ul>
<li>作者样式表: 网站开发者的编写，被视为最重要的样式表。</li>
<li>用户样式表: 用户通过浏览器自定义的样式，这些样式表的权重要比网站开发者的样式表低一级。</li>
<li>浏览器/用户代理应用的样式: 浏览器或用户代理默认的样式，这些可以随意覆盖是最低级的。</li>
</ul>
<p>按照上面的分析，咱们就有了以下排序(权重由高到低):</p>
<ol>
<li>标有 !important 的用户样式表</li>
<li>标有 !important 的作者样式表</li>
<li>作者样式表</li>
<li>用户样式表</li>
<li>浏览器/用户代理的默认样式表</li>
</ol>
<p>根据优先级覆盖样式，如果优先级相同，则后者覆盖前者。</p>
<h2 id="u7279_u6B8A_u6027"><a href="#u7279_u6B8A_u6027" class="headerlink" title="特殊性"></a>特殊性</h2><p>为了方便计算选择器之间的权重，我们引入特殊性这个概念，通常我们会给每种选择器分配一个数字。然后，将规则的每种选择器的值加在一起，计算出规则的权重。通常来说，如果一个特定选择器中的选择器少于10个，那我们就能以10为基数计算特殊性。</p>
<p>选择器的特殊性分成 4 个等级：a，b，c，d。</p>
<ul>
<li>如果是行内样式, a = 1</li>
<li>ID 选择器的总数等于 b 的值</li>
<li>类选择器、伪类选择器和属性选择器总数等于 c 的值</li>
<li>类型选择器和伪元素选择器的总数等于 d 的值</li>
</ul>
<p>特殊性示例</p>
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:center">特殊性</th>
<th style="text-align:center">以10为基数的特殊性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">style=””</td>
<td style="text-align:center">1,0,0,0</td>
<td style="text-align:center">1000</td>
</tr>
<tr>
<td style="text-align:left">#wrapper #content {}</td>
<td style="text-align:center">0,2,0,0</td>
<td style="text-align:center">200</td>
</tr>
<tr>
<td style="text-align:left">#content .title {}</td>
<td style="text-align:center">0,1,1,0</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:left">div#content {}</td>
<td style="text-align:center">0,1,0,1</td>
<td style="text-align:center">101</td>
</tr>
<tr>
<td style="text-align:left">#content {}</td>
<td style="text-align:center">0,1,0,0</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:left">p.comment .putdate {}</td>
<td style="text-align:center">0,0,2,1</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:left">p.comment {}</td>
<td style="text-align:center">0,0,1,1</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:left">div p {}</td>
<td style="text-align:center">0,0,0,2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:left">p {}</td>
<td style="text-align:center">0,0,0,1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>根据基数覆盖，如果基数相同，则后者覆盖前者。</p>
<p>比如,下面这段代码,最后的颜色是灰色：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#content</span> <span class="tag">div</span><span class="id">#main-content</span> <span class="tag">h2</span><span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> gray</span></span>; &#125;</span>    <span class="comment">/* 100*2 + 1*2 = 202 */</span>  </span><br><span class="line"><span class="id">#content</span> <span class="id">#main-content</span>&gt;<span class="tag">h2</span><span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> blue</span></span>; &#125;</span>       <span class="comment">/* 100*2 + 1 = 201 */</span></span><br></pre></td></tr></table></figure>
<h2 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h2><p>应用样式的元素的后代会继承样式的某些属性，比如字号、颜色等。假如你设置了以下代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body&#123; font-size: 20px;&#125;</span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>标题<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你会发现，h1 和 h2 元素并未继承 20px 的大小，因为浏览器默认样式覆盖了它。</p>
<p>继承来的样式的权重为 0,任何直接设置的样式都可以覆盖。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个样式表中要查找同一个元素，我们可以通过多种规则找到。CSS 通过一个成为<code>层叠</code>的过程处理这种冲突。</p>
<h2 id="u5C42_u53E0"><a href="#u5C42_u53E0" class="headerlink" title]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5新增元素介绍]]></title>
    <link href="http://imhzq.com/2015/11/01/20151101_new-tag-from-html5/"/>
    <id>http://imhzq.com/2015/11/01/20151101_new-tag-from-html5/</id>
    <published>2015-10-31T16:00:00.000Z</published>
    <updated>2015-12-12T15:45:25.000Z</updated>
    <content type="html"><![CDATA[<p>HTML5 新增了一些元素为了用于更好的文档结构，使用这些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！</p>
<h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><p><code>section</code> 元素表示一般意义上的区域/章节，，比如内容中的一个专题，一般会与<code>h1</code>~<code>h6</code>等元素搭配使用，以标示文档层级。如果元素内容可以分为几个部分的话，应该使用 <code>article</code> 而不是 <code>section</code>。不要把 <code>section</code> 元素作为一个普通的容器来使用，这种情况下 <code>div</code> 元素比他更合适，特别是仅仅用作美化样式的情况下。通常来说 <code>section</code> 应该出现在文档的框架中。</p>
<h3 id="article"><a href="#article" class="headerlink" title="article"></a>article</h3><p><code>article</code> 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，它可能是论坛帖子、文章、博客、用户提交评论或者是其它的独立内容项目。当 <code>article</code> 元素嵌套使用时，则该元素代表与外层元素有关的文章，例如代表博客评论的 <code>article</code> 元素可嵌套在代表博客文章的 <code>article</code> 元素中。</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p><code>main</code> 元素呈现了文档 <code>body</code> 或应用的主体部分，这部分内容在文档中应该是独一无二的，在一个文档中不能出现一个以上的 <code>main</code>,不能是以下元素的继承 <code>article</code>,<code>aside</code>,<code>footer</code>,<code>header</code>,<code>nav</code>。</p>
<h3 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h3><p><code>aside</code> 元素代表与了一些与页面其他部分关联性不是那么大的内容，比如广告。</p>
<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p><code>header</code> 代表了一组介绍性或者导航性质的辅助内容，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。<code>header</code> 不是分节元素，不会引入分节到大纲中。</p>
<h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p><code>footer</code> 元素表示最近的一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节坐着、版权数据或者文档相关的链接信息。</p>
<h3 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h3><p><code>nav</code> 代表一个含有多个超链接的区域。</p>
<h3 id="figure"><a href="#figure" class="headerlink" title="figure"></a>figure</h3><p><code>figure</code> 代表一个独立的内容流，常与 <code>figcaption</code> 元素一起出现。</p>
<h3 id="figcaption"><a href="#figcaption" class="headerlink" title="figcaption"></a>figcaption</h3><p><code>figcaption</code> 用作 <code>figure</code> 的标题，类似于表格的 <code>caption</code> 元素。</p>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p><code>template</code> 元素是一种机制，允许包含加载页面时不渲染，但又可以随后通过 Javascript 实力化的客户端内容，就像我们这样做一样<code>script type=&quot;text/temple&quot;</code>。</p>
<h3 id="audio__26amp_3B_video"><a href="#audio__26amp_3B_video" class="headerlink" title="audio &amp; video"></a>audio &amp; video</h3><p><code>audio</code> 和 <code>video</code> 是多媒体元素，他们提供相对应的 API 用于开发者定制 UI，同时也提供了出发 UA 展示其默认控件的方式。</p>
<h3 id="embed"><a href="#embed" class="headerlink" title="embed"></a>embed</h3><p><code>embed</code> 元素表示一个插件，展用于插件内容。</p>
<h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p><code>mark</code> 元素代表了一个文档中需要标记或者高亮的部分，比如说搜索引擎搜索后的关键词。不要为了语法高亮而去使用 mark，应该使用 <code>strong</code> 元素，<code>mark</code> 元素表示上下文的关联性。</p>
<h3 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h3><p><code>progress</code> 用来表示一个进度条,代表一个任务的完成进度。</p>
<h3 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h3><p><code>meter</code> 代表了一个度量，比如对磁盘空间的度量。</p>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><code>time</code> 表示一个时间。有两个属性,datetime(一个有效的时间格式，表示具体时间),pubdate(一般用于文章发布时间，评论回复时间等)。</p>
<h3 id="ruby_u3001rt_u3001rp"><a href="#ruby_u3001rt_u3001rp" class="headerlink" title="ruby、rt、rp"></a>ruby、rt、rp</h3><p><code>ruby</code>、<code>rt</code>、<code>rp</code> 代表 Ruby 表达式。</p>
<h3 id="bdi"><a href="#bdi" class="headerlink" title="bdi"></a>bdi</h3><p><code>bdi</code> 代表了一段隔绝于周围元素的双向书写文本格式。</p>
<h3 id="wbr"><a href="#wbr" class="headerlink" title="wbr"></a>wbr</h3><p><code>bdi</code> 代表了可能断行的部分。</p>
<h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p><code>canvas</code> 用于渲染动态位图。</p>
<h3 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h3><p><code>datalist</code> 与input的list属性共同使用，可以用于创建下拉选择框控件。</p>
<h3 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h3><p><code>keygen</code> 代表生成的密钥对。</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>output</code> 代表了一种输出内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTML5 新增了一些元素为了用于更好的文档结构，使用这些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！</p>
<h3 id="section"><a href="#section" class="headerlink" title="s]]>
    </summary>
    
      <category term="HTML5" scheme="http://imhzq.com/tags/HTML5/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[参加与大师面对面活动后的小心思]]></title>
    <link href="http://imhzq.com/2015/10/24/20151024_type-script-anders-hejlsberg/"/>
    <id>http://imhzq.com/2015/10/24/20151024_type-script-anders-hejlsberg/</id>
    <published>2015-10-23T16:00:00.000Z</published>
    <updated>2015-12-12T15:12:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/IMG_0078.JPG" alt="小心思"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7u2ksn.com1.z0.glb.clouddn.com/IMG_0078.JPG" alt="小心思"></p>
]]>
    </summary>
    
      <category term="-生活" scheme="http://imhzq.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Emotion" scheme="http://imhzq.com/categories/Emotion/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重排与重绘]]></title>
    <link href="http://imhzq.com/2015/09/01/20150901_repaints-and-reflows/"/>
    <id>http://imhzq.com/2015/09/01/20150901_repaints-and-reflows/</id>
    <published>2015-08-31T16:00:00.000Z</published>
    <updated>2015-12-12T15:52:28.000Z</updated>
    <content type="html"><![CDATA[<p>浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当DOM元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。</p>
<p>重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面UI反应吃顿。应当尽量减少重排和重绘。</p>
<h2 id="u4F55_u65F6_u91CD_u6392"><a href="#u4F55_u65F6_u91CD_u6392" class="headerlink" title="何时重排"></a>何时重排</h2><ol>
<li>页面渲染器初始化的时候</li>
<li>浏览器窗口发生尺寸变化时</li>
<li>删除或添加新的可见 DOM 元素</li>
<li>元素的位置改变</li>
<li>元素的盒子模型发生变化</li>
<li>元素内容发生变化（引起盒子模型发生变化）</li>
</ol>
<h2 id="u51CF_u5C11_u91CD_u6392_u548C_u91CD_u7ED8"><a href="#u51CF_u5C11_u91CD_u6392_u548C_u91CD_u7ED8" class="headerlink" title="减少重排和重绘"></a>减少重排和重绘</h2><p>每次重绘和重排都会产生大量消耗，我们在编码时应当避免。</p>
<h3 id="u6E32_u67D3_u6811_u961F_u5217_u7684_u961F_u5217_u4E0E_u5237_u65B0"><a href="#u6E32_u67D3_u6811_u961F_u5217_u7684_u961F_u5217_u4E0E_u5237_u65B0" class="headerlink" title="渲染树队列的队列与刷新"></a>渲染树队列的队列与刷新</h3><p>大多数浏览器都会优化这个队列，通过批量执行等方式来优化重排过程，然而你可能会不经意间强制要求浏览器放弃优化，立即执行队列并刷新。</p>
<p>调用下面这些方法时，浏览器为了能返回正确的数据，会立即触发重排：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetTop, offsetLeft, offsetWidth, offsetHeight</span><br><span class="line">scrollTop, scrollLeft, scrollWidth, scrollHeight</span><br><span class="line">clientTop, clientLift, clientWidth, clientHeight</span><br><span class="line">getComputedStyle()</span><br></pre></td></tr></table></figure></p>
<h3 id="u4F18_u5316_u4EE3_u7801"><a href="#u4F18_u5316_u4EE3_u7801" class="headerlink" title="优化代码"></a>优化代码</h3><p>考虑这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.style.borderLeft = <span class="string">'1px'</span>;</span><br><span class="line">el.style.borderRight = <span class="string">'2px'</span>;</span><br><span class="line">el.style.margin = <span class="string">'3px'</span>;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，浏览器会优化这个，只发生一次重排。但是，如果在这期间有其他代码请求布局信息，会导致浏览器三次重排。一个更高效的方法就是，使用 cssText，只修改一次 DOM：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.style.cssText += <span class="string">"border-left:1px;border-right:2px;margin:3px;"</span>;</span><br></pre></td></tr></table></figure></p>
<p>另一个方法是修改元素的 class 名称，这种方法更清晰，更易维护，但是会带来轻微的性能营销，因为改变类时需要检查及联样式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.className = <span class="string">"active"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="u6279_u91CF_u4FEE_u6539_DOM"><a href="#u6279_u91CF_u4FEE_u6539_DOM" class="headerlink" title="批量修改 DOM"></a>批量修改 DOM</h3><p>当需要对 DOM 元素进行一连串的操作时，可以先让元素脱离文档流，然后对其应用多重改变，再把元素加入文档流。第一步和第三步会触发两次重排，如果不这么做，第二步做的任何修改都会触发一次重排。</p>
<p>那么怎么才能让元素脱离文档流哪？ 有三种基本方法：</p>
<ol>
<li>隐藏元素，应用修改，重新显示</li>
<li>使用文档片段 (document fragment) 在当前 DOM 之外构建一个子树，再把它拷贝回文档</li>
<li>创建一个需要修改节点的镜像，然后修改镜像，再用镜像替换原节点</li>
</ol>
<p>比如我们需要向列表中添加一些项，如下</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"url1"</span>&gt;</span>Name1<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"url2"</span>&gt;</span>Name2<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">var data = [</span><br><span class="line">    </span><span class="expression">&#123;<span class="variable">url</span>: <span class="string">"url1"</span>, <span class="variable">name</span>: <span class="string">"Name1"</span>&#125;</span><span class="xml">,</span><br><span class="line">    </span><span class="expression">&#123;<span class="variable">url</span>: <span class="string">"url2"</span>, <span class="variable">name</span>: <span class="string">"Name2"</span>&#125;</span><span class="xml"></span><br><span class="line">]</span></span><br></pre></td></tr></table></figure>
<p>我们写一个添加的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">to, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> link, li, item;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++)&#123;</span><br><span class="line">        item = data[i];</span><br><span class="line">        link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">        link.href = item.url;</span><br><span class="line">        link.appendChild(<span class="built_in">document</span>.createTextNode(item.name));</span><br><span class="line">        li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">        li.appendChild(link);</span><br><span class="line">        to.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>
<p>如果使用这种方法， data 数组中的每一个新条目被增加到 DOM 树中都会导致重绘，我们可以此用第一种方法，改变需要重排元素的 display 属性，从而使其脱离文档流，添加完成后，在修改 display 属性，使其添加回文档流中，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">ul.style.display = <span class="string">"none"</span>;</span><br><span class="line">appendDataToElementById(ul, data);</span><br><span class="line">ul.style.display = <span class="string">"block"</span></span><br></pre></td></tr></table></figure>
<p>第二种减少重排的方法就是使用文档片段，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<p>第三种方式，需要为原节点创建一个镜像，添加完成后，再替换原来的DOM节点，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">var</span> cloneUl = ul.cloneNode(<span class="literal">true</span>);</span><br><span class="line">appendDataToElement(cloneUl, data);</span><br><span class="line">ul.parentNode.replaceChild(cloneUl,ul);</span><br></pre></td></tr></table></figure>
<p>推荐使用第二种方案，它操作DOM的次数最少。</p>
<h3 id="u7F13_u5B58_u5E03_u5C40_u4FE1_u606F"><a href="#u7F13_u5B58_u5E03_u5C40_u4FE1_u606F" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h3><p>我们在用定时器写动画的时候，经常会出现这种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = el.style;</span><br><span class="line">es.left = <span class="number">1</span> + el.offsetLeft + <span class="string">"px"</span>;</span><br><span class="line">es.top = <span class="number">1</span> + el.offsetTop + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure></p>
<p>前面说过，这种写法会使浏览器强制重排获取正确的属性值，每次 ＋1 都会触发重排，我们可以将移动信息做缓存，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = el.style, positionNum = el.offsetLeft;</span><br><span class="line">es.left = ++positionNum;</span><br></pre></td></tr></table></figure>
<p>这样，我们就避免了，多次重排!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当DOM元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[即兴小诗]]></title>
    <link href="http://imhzq.com/2015/05/11/20150511_impromptu-poetry/"/>
    <id>http://imhzq.com/2015/05/11/20150511_impromptu-poetry/</id>
    <published>2015-05-10T16:00:00.000Z</published>
    <updated>2015-12-13T13:32:54.000Z</updated>
    <content type="html"><![CDATA[<p>两轮考勤一日志，系向OA充薪直。<br>长太息以掩涕零，哀码农之多坚。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>两轮考勤一日志，系向OA充薪直。<br>长太息以掩涕零，哀码农之多坚。</p>
]]>
    </summary>
    
      <category term="生活" scheme="http://imhzq.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Emotion" scheme="http://imhzq.com/categories/Emotion/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sass系列之基本语法]]></title>
    <link href="http://imhzq.com/2015/04/19/20150419_learn-sass-basesyntax/"/>
    <id>http://imhzq.com/2015/04/19/20150419_learn-sass-basesyntax/</id>
    <published>2015-04-19T06:08:15.000Z</published>
    <updated>2015-12-12T15:53:56.000Z</updated>
    <content type="html"><![CDATA[<p>Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 CSS 语法。 Sass 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 Compass 样式库一同使用时，犹如豆浆和油条双剑合并！</p>
<h2 id="sass__u6587_u4EF6_u7C7B_u578B"><a href="#sass__u6587_u4EF6_u7C7B_u578B" class="headerlink" title="sass 文件类型"></a>sass 文件类型</h2><p>sass 有两种文件格式,一种是 <code>*.scss</code> 一种是 <code>*.sass</code>,分别代表了两种 sass 的语法,最终编译生成的 css 是一致的。</p>
<p><code>sass</code> 与 Ruby 的语法很相似,对内容格式有着严格的要求。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#body</span></span><br><span class="line">    <span class="attribute">background</span><span class="value">: <span class="hexcolor">#fff</span></span><br><span class="line">#title</span><br><span class="line">    margin: <span class="number">0</span> auto</span></span><br></pre></td></tr></table></figure>
<p><code>scss</code> 则更贴近 css 语法，如何选择，大家各取所爱，但是在同一个文件中请不要出现两种语法，一个文件一种格式。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span><span class="value">: <span class="hexcolor">#fff</span>;</span></span><br><span class="line">    <span class="id">#title</span>&#123;</span><br><span class="line">        <span class="attribute">margin</span><span class="value">: <span class="number">0</span> auto;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这两者也是可以转换的，我们可以使用 sass 内置的 <code>sass-convert</code> 命令来互相转换</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 style.scss 转换为 style.sass</span></span><br><span class="line">sass-convert style<span class="class">.scss</span> style.sass</span><br></pre></td></tr></table></figure>
<p>在学习过程中，大家可以互相转换，了解学习对应的语法书写方式。</p>
<h2 id="u7F16_u8BD1"><a href="#u7F16_u8BD1" class="headerlink" title="编译"></a>编译</h2><h3 id="sass__u7F16_u8BD1"><a href="#sass__u7F16_u8BD1" class="headerlink" title="sass 编译"></a>sass 编译</h3><p>我们编写好 sass 文件后，可以用 sass 命令来编译成 css<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 style.scss 编译成 style.css</span></span><br><span class="line">sass style<span class="class">.scss</span> style.css</span><br></pre></td></tr></table></figure></p>
<p>大家可能会觉得如此麻烦，有没有什么办法能够，编写 sass 后，直接生成对应的 css 文件那</p>
<p>当然有，我们可以使用 compass 或者 gulp、grunt 来实现这项功能。</p>
<p>gulp 和 grunt 是前端开发的脚手架，我们会在另外的文章里详细讲解，这里我们先简单介绍下 compass。</p>
<h3 id="u901A_u8FC7_compass__u7F16_u8BD1_sass"><a href="#u901A_u8FC7_compass__u7F16_u8BD1_sass" class="headerlink" title="通过 compass 编译 sass"></a>通过 compass 编译 sass</h3><p>我们现在安装 compass, 和 sass 一样，我们通过 gem 来安装 compass</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> compass</span><br></pre></td></tr></table></figure>
<p>通过 compass 初始化项目</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//learn-sass 是要创建的项目文件夹</span></span><br><span class="line">compass <span class="keyword">create</span> learn-sass</span><br></pre></td></tr></table></figure>
<p>打开我们的文件夹，文件结构就是这样的</p>
<p>learn-sass<br><br>    &nbsp;&nbsp;|- .sass-cache<br><br>    &nbsp;&nbsp;|- sass<br><br>    &nbsp;&nbsp;|- stylesheets<br><br>    &nbsp;&nbsp;|- config.rb<br></p>
<p><code>.sass-cache</code> 是 sass 编译缓存存放的地方</p>
<p><code>sass</code> 存放的就是我们编写的 <em>.scss 和 </em>.sass 文件</p>
<p><code>stylesheets</code> 里面是 compass 帮我们将 sass 文件夹内的 <em>.sass 和 </em>.scss 文件编译成的 css 文件</p>
<p><code>config.rb</code> 里面是 compass 的配置信息，具体说明，我会在另外一篇文章中详细介绍</p>
<p>执行 <code>compass watch</code> 后，修改 sass 中的文件，compass 会自动帮我们生成 css 到 stylesheets 文件夹中</p>
<h2 id="u57FA_u672C_u8BED_u6CD5"><a href="#u57FA_u672C_u8BED_u6CD5" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="u53D8_u91CF_u58F0_u660E"><a href="#u53D8_u91CF_u58F0_u660E" class="headerlink" title="变量声明"></a>变量声明</h3><p>是的，css 中，可以像其他语言一样声明变量了，声明方式以 $ 符开头</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="variable">$titleColor</span><span class="value">: <span class="hexcolor">#0f0</span>;</span></span><br><span class="line"><span class="variable">$titleWidth</span><span class="value">: <span class="number">16px</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">background</span><span class="value">: <span class="variable">$titleColor</span>;</span></span><br><span class="line">    <span class="attribute">width</span><span class="value">: <span class="variable">$titleWidth</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把常用的数值，声明成变量，让我们的项目结构清晰易维护</p>
<h3 id="@import"><a href="#@import" class="headerlink" title="@import"></a>@import</h3><p>通常我们会把所有的变量，统一的放在一个 <code>_variables.scss</code> 文件中，然后在用到的地方中通过 @import “variables.scss” 的方式来引用这些变量, 我们可以省略</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="string">"variables"</span>;</span></span><br></pre></td></tr></table></figure>
<p>大家肯定已经想到了 css 中的 @import 功能，这个和那个又有什么区别哪</p>
<p>css 中的 @import 必须放在代码最前面，并且会阻塞浏览器，性能不优，我们尽量避免使用， sass 中重新定义了 @import 可以在任何地方使用。 那我们如果真的想用 css 自己的 @import 时，我们可以用以下方式表示使用原生的</p>
<ol>
<li>当@import 后边跟的文件名时 ＊.css时</li>
<li>当@import 后边跟的是 <a href="http://开头的字符串时" target="_blank" rel="external">http://开头的字符串时</a></li>
<li>当@import 后面跟的是 url() 函数时</li>
<li>当@import 后面跟的时 media queries 的时候</li>
</ol>
<h3 id="u6CE8_u91CA"><a href="#u6CE8_u91CA" class="headerlink" title="注释"></a>注释</h3><p>sass 中可以使用 css 原生的注释，也可以使用 双斜线这种注释方式，具体区别如下 </p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这种注释方式会出现在生成的 css代码中 */</span></span><br><span class="line"><span class="comment">// 这种注释方式不会出现在生成的 css代码中</span></span><br></pre></td></tr></table></figure>
<h3 id="u5D4C_u5957"><a href="#u5D4C_u5957" class="headerlink" title="嵌套"></a>嵌套</h3><p>sass 提供了两种嵌套方式，分别是属性嵌套和选择器的嵌套，能极大的降低选择器和属性的重复书写，如下</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#header</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">20px</span>;</span></span><br><span class="line">    <span class="attribute">height</span><span class="value">:<span class="number">300px</span>;</span></span><br><span class="line">    <span class="tag">title</span>&#123;</span><br><span class="line">        <span class="attribute">font</span><span class="value">:&#123; //属性嵌套使用 :</span><br><span class="line">            size:<span class="number">18px</span>;</span></span><br><span class="line">            weight<span class="value">: normal;</span></span><br><span class="line">        &#125;</span><br><span class="line">        &amp;<span class="pseudo">:hover</span>&#123;    <span class="comment">//&amp; 符号在 sass 中表示父级选择器，这里就是 title</span></span><br><span class="line">            <span class="attribute">color</span><span class="value">:<span class="hexcolor">#fff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#header</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">20px</span>;</span></span><br><span class="line">    <span class="attribute">height</span><span class="value">:<span class="number">300px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="id">#header</span> <span class="tag">title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span><span class="value">:<span class="number">18px</span>;</span></span><br><span class="line">    <span class="attribute">font-weight</span><span class="value">: normal;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="id">#header</span> <span class="tag">title</span><span class="pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span><span class="value">:<span class="hexcolor">#fff</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比一下，是不是可以少写很多的代码了那</p>
<h3 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h3><p>刚才我们讲了变量，变量的操作有两种，一种是直接变量操作，一种是通过函数操作</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$titleWidth</span><span class="value">:<span class="number">24px</span> + <span class="number">5</span>;</span> <span class="comment">//sass 变量支持基本的算数运算，&gt;= &lt;= &lt; &gt; == != ()</span></span><br></pre></td></tr></table></figure>
<p>函数操作，一种是通过 sass 内部定义的函数，称作 functions，第二种是可重用的代码块，称作 mixin，我们主要讲 mixin 这种方式</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 mixin</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> col-12</span>&#123;</span></span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">100%</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="class">.title</span>&#123;</span><br><span class="line">    <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> col-12</span>();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后生成</span></span><br><span class="line"><span class="class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">: <span class="number">100%</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，既然是函数，我们可以传入参数值</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义带参数的 mixin</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> col</span> (<span class="variable">$width</span>)&#123;</span></span><br><span class="line">    <span class="attribute">width</span><span class="value">: <span class="variable">$width</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式和无参是一样的</span></span><br><span class="line"><span class="class">.title</span>&#123;</span><br><span class="line">    <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> col</span>(<span class="number">100%</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数默认值也是有的哦</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@定义带参数有默认值的 mixin</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> col</span> (<span class="variable">$width</span>:<span class="number">100%</span>)&#123;</span>   <span class="comment">//参数后跟 : 指定默认值</span></span><br><span class="line">    <span class="attribute">width</span> <span class="value">: <span class="variable">$width</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h3><p>sass 通过 @extent 可以继承其他选择器的样式</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">color</span><span class="value">:<span class="hexcolor">#fff</span>;</span></span><br><span class="line">    <span class="attribute">float</span><span class="pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.left</span>&#123;</span><br><span class="line">    <span class="at_rule">@extent<span class="preprocessor"> .content</span>;</span> <span class="comment">//通过 @extent 继承 .content 选择器的样式</span></span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">30%</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="class">.content</span>, <span class="class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">color</span><span class="value">:<span class="hexcolor">#fff</span>;</span></span><br><span class="line">    <span class="attribute">float</span><span class="pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">: <span class="number">30%</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@extent 不能继承选择器序列，可以用 %声明样式，来表示这是个只继承的样式</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择器序列</span></span><br><span class="line"><span class="class">.left</span> <span class="class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">200px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.right</span>&#123;</span><br><span class="line">    <span class="at_rule">@extent<span class="preprocessor"> .left</span><span class="preprocessor"> .name</span>;</span> <span class="comment">//这会报语法错误，不能继承选择器序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="variable">$title</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">30</span>xp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.left</span>&#123;</span><br><span class="line">    <span class="at_rule">@extent <span class="variable">$title</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span><span class="value">:<span class="number">30</span>xp;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>那么，我们今天的基本语法讲完了，就先写到这里吧，其他高级特性，咱们下回再细谈！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 CSS 语法。 Sass 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 Compass 样式库一同使]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="Sass" scheme="http://imhzq.com/tags/Sass/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sass系列之安装]]></title>
    <link href="http://imhzq.com/2015/04/17/20150417_learn-sass-step/"/>
    <id>http://imhzq.com/2015/04/17/20150417_learn-sass-step/</id>
    <published>2015-04-17T09:13:05.000Z</published>
    <updated>2015-12-12T15:54:14.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a> 对 CSS3 的语法进行了扩充，增加了新的规则、变量、函数、选择器、继承等特性，让 css 看起来更像一门语言，这种特性也被称作“css预编译”，我们通过它可以用编程的思路去写样式，然后通过编译生成我们需要的样式表文件。</p>
<p>当然，类似的还有 Less、stylus 等，关键还是找到趁手的。</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><h3 id="u5B89_u88C5_Ruby__u8FD0_u884C_u73AF_u5883"><a href="#u5B89_u88C5_Ruby__u8FD0_u884C_u73AF_u5883" class="headerlink" title="安装 Ruby 运行环境"></a>安装 Ruby 运行环境</h3><p>因为 Sass 引擎是用 Ruby 编写的，所以我们安装 Sass 前，需要先安装 Ruby 运行环境，既然要安装 Ruby，那么我们先来安装 RVM 吧，RVM 和 NVM 概念差不多，RVM 是 Ruby 的版本管理工具</p>
<p>我们通过下面命令来安装 RVM<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="operator">-s</span>SL https://get.rvm.io | bash <span class="operator">-s</span> stable</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，我们用下面的命令列出可以安装的 Ruby 版本</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="type">list</span> known</span><br></pre></td></tr></table></figure>
<p>我们通过 install 命令来安装对应的 Ruby 2.2.0 版本<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install <span class="number">2.2</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p>
<p>至此，Ruby 环境就好了，RVM 的具体使用方式这里就不赘述了,详情可以参考官网 <a href="https://rvm.io" target="_blank" rel="external">https://rvm.io</a></p>
<h3 id="u5B89_u88C5Sass"><a href="#u5B89_u88C5Sass" class="headerlink" title="安装Sass"></a>安装Sass</h3><p>安装好 Ruby 环境后，通过 gem 包管理工具安装 Sass，因为国内网络环境复杂，使用前可先将 gem 的源替换成淘宝的<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除源</span></span><br><span class="line">gem sources --remove <span class="string">https:</span><span class="comment">//rubygems.org/</span></span><br><span class="line"><span class="comment">//新增源</span></span><br><span class="line">gem sources --a <span class="string">https:</span><span class="comment">//ruby.taobao.org/</span></span><br><span class="line"><span class="comment">//查看替换结果</span></span><br><span class="line">gem sources -l</span><br><span class="line"><span class="comment">//安装Sass</span></span><br><span class="line">gem install sass</span><br></pre></td></tr></table></figure></p>
<p>我们的 Sass 安装就完成了，下节我们就可以愉快的使用 Sass 了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a> 对 CSS3 的语法进行了扩充，增加了新的规则、变量、函数、选择器、继承等特性，让 css 看起来更像一门语言，这种特性也被称作“]]>
    </summary>
    
      <category term="Css" scheme="http://imhzq.com/tags/Css/"/>
    
      <category term="Sass" scheme="http://imhzq.com/tags/Sass/"/>
    
      <category term="前端" scheme="http://imhzq.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="FE" scheme="http://imhzq.com/categories/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <link href="http://imhzq.com/2015/04/10/20150410_first-article/"/>
    <id>http://imhzq.com/2015/04/10/20150410_first-article/</id>
    <published>2015-04-09T16:00:00.000Z</published>
    <updated>2015-12-12T15:54:37.000Z</updated>
    <content type="html"><![CDATA[<p>折腾来折腾去，总算是有个家了！两个月前搭建起来这个博客，到现在才决心要好好维护下去，真是惭愧啊。</p>
<p>总之，今后我会在这里记录写生活琐碎、音乐、技术分享等等。</p>
<p>博客由 <a href="http://hexo.io" target="_blank" rel="external">hexo</a> 驱动，部署于 <a href="https://github.com/Simlesos" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>折腾来折腾去，总算是有个家了！两个月前搭建起来这个博客，到现在才决心要好好维护下去，真是惭愧啊。</p>
<p>总之，今后我会在这里记录写生活琐碎、音乐、技术分享等等。</p>
<p>博客由 <a href="http://hexo.io" target="_blank" ]]>
    </summary>
    
      <category term="生活" scheme="http://imhzq.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Emotion" scheme="http://imhzq.com/categories/Emotion/"/>
    
  </entry>
  
</feed>
